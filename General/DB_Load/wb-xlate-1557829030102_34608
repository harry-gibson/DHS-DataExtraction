#! encoding="UTF-8"
#    Command-line to run this workspace:
#        "C:\Program Files\FME2018\fme.exe" C:/Users/zool1301.NDPH/Documents/DHS/Data_Extraction_Code/General/DB_Load\wb-xlate-1557829030102_34608
#              --SourceDataset_PATH "C:\Temp\304"
#              --DestDataset_POSTGRES "Admin<space>on<space>MAP-FS1<space><openparen>DHS<space>instance<closeparen>"
#              --DestDataset_CSV "C:\Temp\304"
#              --SourceDataset_FFS_3 "\\map-fs1.ndph.ox.ac.uk\map_data\DHS_Automation\Acquisition\Update_Logs\20181107_Updates\AlSchemas_To_20181107.ffs"
#              --SourceDataset_CSV2 "E:\Data\Harry\Documents\dataprep\DHS_Updates\update_logs\New_Table_Columns_By_Survey.csv"
#              --Force_Reload_Existing "0"
#              --Load_New_Tables "1"
#              --DestDataset_POSTGRES_3 "Admin<space>on<space>MAP-FS1<space><openparen>DHS<space>instance<closeparen>"
#    

MACRO FME_MF_NAME Load_DHS_Data_To_PG_With_Checks.fmw
MACRO FME_MF_NAME_MASTER Load_DHS_Data_To_PG_With_Checks.fmw

FME_PYTHON_VERSION 27
GUI IGNORE PATH_IN_GLOB_PATTERN_PATH_1,PATH_IN_TYPE_PATH_1,PATH_IN_RETRIEVE_FILE_PROPERTIES_PATH_1,SourceDataset_PATH_1,PATH_IN_NETWORK_AUTHENTICATION_PATH_1,SourceDataset_FFS_1,FFS_IN_PASSPHRASE_FFS_1,FFS_IN_EXPOSE_ATTRS_GROUP_FFS_1,FFS_IN_FFS_SPATIAL_INDEXES_FFS_1,FFS_IN_SEARCH_CLOSEST_POINT_FFS_1,FFS_IN_SEARCH_ENVELOPE_MINX_FFS_1,FFS_IN_SEARCH_ENVELOPE_MINY_FFS_1,FFS_IN_SEARCH_ENVELOPE_MAXX_FFS_1,FFS_IN_SEARCH_ENVELOPE_MAXY_FFS_1,FFS_IN_SEARCH_ENVELOPE_COORDINATE_SYSTEM_FFS_1,FFS_IN_CLIP_TO_ENVELOPE_FFS_1,FFS_IN_NETWORK_AUTHENTICATION_FFS_1,SourceDataset_CSV2_1,CSV2_IN_DATASET_GROUP_CSV2_1,CSV2_IN_FIELDS_GROUP_CSV2_1,CSV2_IN_DELIMITER_CSV2_1,CSV2_IN_FIELD_NAMES_LINE_CSV2_1,CSV2_IN_DATA_START_LINE_CSV2_1,CSV2_IN_ADVANCED_GROUP_CSV2_1,CSV2_IN_FIELD_SEPARATION_GROUP_CSV2_1,CSV2_IN_SKIP_DUPLICATE_DELIMITERS_CSV2_1,CSV2_IN_FIELD_QUALIFIER_CHARACTER_CSV2_1,CSV2_IN_FIELD_QUALIFIER_ESCAPE_CHARACTER_CSV2_1,CSV2_IN_FIELD_NAMES_GROUP_CSV2_1,CSV2_IN_CASE_SENSITIVE_FIELD_NAMES_CSV2_1,CSV2_IN_ENFORCE_STRICT_SCHEMA_CSV2_1,CSV2_IN_FIELD_VALUES_GROUP_CSV2_1,CSV2_IN_TRIM_FIELD_VALUE_QUALIFIERS_CSV2_1,CSV2_IN_ENCODING_GROUP_CSV2_1,CSV2_IN_ENCODING_CSV2_1,CSV2_IN_PRESERVE_SOURCE_ENCODING_CSV2_1,CSV2_IN_SKIPPED_LINES_GROUP_CSV2_1,CSV2_IN_READ_SKIPPED_LINES_CSV2_1,CSV2_IN_SCHEMA_GENERATION_GROUP_CSV2_1,CSV2_IN_EXPOSE_ATTRS_GROUP_CSV2_1,CSV2_IN_NETWORK_AUTHENTICATION_CSV2_1,DestDataset_POSTGRES_1,POSTGRES_OUT_WRITER_MODE_POSTGRES_1,POSTGRES_OUT_START_TRANSACTION_POSTGRES_1,POSTGRES_OUT_TRANSACTION_INTERVAL_POSTGRES_1,POSTGRES_OUT_BULK_COPY_POSTGRES_1,POSTGRES_OUT_BEGIN_SQL_POSTGRES_1,POSTGRES_OUT_END_SQL_POSTGRES_1,DestDataset_CSV_1,CSV_OUT_EXTENSION_CSV_1,CSV_OUT_APPEND_CSV_1,CSV_OUT_FIELD_NAMES_CSV_1,CSV_OUT_WRITE_SCHEMA_FILE_CSV_1,CSV_OUT_PREPEND_SCHEMA_FILE_CSV_1,CSV_OUT_SEPARATOR_CSV_1,CSV_OUT_ENCODING_CSV_1,CSV_OUT_WRITE_UTF8_BOM_CSV_1,CSV_OUT_QUOTE_OUTPUT_CSV_1,CSV_OUT_QUOTE_FIELD_NAMES_CSV_1,CSV_OUT_END_OF_LINE_CSV_1,DestDataset_POSTGRES_2,POSTGRES_OUT_START_TRANSACTION_POSTGRES_2,POSTGRES_OUT_TRANSACTION_INTERVAL_POSTGRES_2,POSTGRES_OUT_BULK_COPY_POSTGRES_2,POSTGRES_OUT_BEGIN_SQL_POSTGRES_2,POSTGRES_OUT_END_SQL_POSTGRES_2
DEFAULT_MACRO SourceDataset_PATH C:\Temp\304
GUI MULTIDIR SourceDataset_PATH Source Folder and File Pathnames Folder:
DEFAULT_MACRO DestDataset_POSTGRES Admin<space>on<space>MAP-FS1<space><openparen>DHS<space>instance<closeparen>
GUI NAMED_DB_CONNECTION_ENCODED DestDataset_POSTGRES FMT:POSTGRES%FAMILY:PostgreSQL Connection:
DEFAULT_MACRO DestDataset_CSV C:\Temp\304
GUI DIRNAME DestDataset_CSV Destination CSV (Comma Separated Value) Folder:
DEFAULT_MACRO SourceDataset_FFS_3 \\map-fs1.ndph.ox.ac.uk\map_data\DHS_Automation\Acquisition\Update_Logs\20181107_Updates\AlSchemas_To_20181107.ffs
GUI MULTIFILE SourceDataset_FFS_3 FME_Feature_Store_Files(*.ffs)|*.ffs|All_Files|* Source FME Feature Store (FFS) File(s):
DEFAULT_MACRO SourceDataset_CSV2 E:\Data\Harry\Documents\dataprep\DHS_Updates\update_logs\New_Table_Columns_By_Survey.csv
GUI MULTIFILE SourceDataset_CSV2 CSV/Compressed_CSV/TEXT_Files(*.csv;*.gz;*.txt)|*.csv;*.gz;*.txt|CSV_Files(*.csv)|*.csv|Compressed_CSV_Files(*.gz)|*.gz|Text_Files(*.txt)|*.txt|All_Files|* Source CSV (Comma Separated Value) File(s):
DEFAULT_MACRO Force_Reload_Existing 0
GUI OPTIONAL LOOKUP_CHOICE Force_Reload_Existing Yes,1%No,0 Reload surveys that appear to be complete in DB, e.g. if data values have changed:
DEFAULT_MACRO Load_New_Tables 1
GUI OPTIONAL LOOKUP_CHOICE Load_New_Tables Yes,1%No,0 Load CSVs which don't even have a table yet:
DEFAULT_MACRO DestDataset_POSTGRES_3 Admin<space>on<space>MAP-FS1<space><openparen>DHS<space>instance<closeparen>
GUI NAMED_DB_CONNECTION_ENCODED DestDataset_POSTGRES_3 FMT:POSTGRES%FAMILY:PostgreSQL Connection:
DEFAULT_MACRO FME_TOPIC_MESSAGE 
GUI IGNORE OPTIONAL FILENAME_EXISTING FME_TOPIC_MESSAGE All_Files(*)|* FME Server Topic Message:
DEFAULT_MACRO FME_SERVER_REQUEST_URI 
GUI IGNORE OPTIONAL STRING FME_SERVER_REQUEST_URI FME Server Request URI:
DEFAULT_MACRO FME_ENGINE 
GUI IGNORE OPTIONAL STRING FME_ENGINE FME Server Engine:
DEFAULT_MACRO FME_TOPIC 
GUI IGNORE OPTIONAL STRING FME_TOPIC FME Server Topic:
DEFAULT_MACRO FME_JOB_ID 
GUI IGNORE OPTIONAL STRING FME_JOB_ID FME Server Job ID:
DEFAULT_MACRO FME_SERVER_REQUEST_HEADERS 
GUI IGNORE OPTIONAL STRING FME_SERVER_REQUEST_HEADERS FME Server Request Headers:
DEFAULT_MACRO FME_SERVER_WEB_URL 
GUI IGNORE OPTIONAL STRING FME_SERVER_WEB_URL FME Server Web URL:
DEFAULT_MACRO FME_SERVER_REQUEST_PARAMETERS 
GUI IGNORE OPTIONAL STRING FME_SERVER_REQUEST_PARAMETERS FME Server Request Parameters:
DEFAULT_MACRO FME_SECURITY_USER 
GUI IGNORE OPTIONAL STRING FME_SECURITY_USER FME Server Security User:
DEFAULT_MACRO FME_SHAREDRESOURCE_TEMP 
GUI IGNORE OPTIONAL DIRNAME_SRC FME_SHAREDRESOURCE_TEMP FME Server Temporary Resource Directory:
DEFAULT_MACRO FME_SERVER_DEST_DIR 
GUI IGNORE OPTIONAL DIRNAME_SRC FME_SERVER_DEST_DIR FME Server Destination Directory:
DEFAULT_MACRO FME_SERVER_HOST 
GUI IGNORE OPTIONAL STRING FME_SERVER_HOST FME Server Host:
DEFAULT_MACRO FME_SERVER_REQUEST_METHOD 
GUI IGNORE OPTIONAL STRING FME_SERVER_REQUEST_METHOD FME Server Request Method:
DEFAULT_MACRO FME_SECURITY_ROLES 
GUI IGNORE OPTIONAL STRING FME_SECURITY_ROLES FME Server Security Roles:
DEFAULT_MACRO FME_DATA_REPOSITORY 
GUI IGNORE OPTIONAL STRING FME_DATA_REPOSITORY FME Server Data Repository:
DEFAULT_MACRO FME_SHAREDRESOURCE_DATA 
GUI IGNORE OPTIONAL DIRNAME_SRC FME_SHAREDRESOURCE_DATA FME Server Resource Data:
DEFAULT_MACRO FME_SERVER_PORT 
GUI IGNORE OPTIONAL STRING FME_SERVER_PORT FME Server Port:
INCLUDE [ if {{$(SourceDataset_PATH)} == {}} { puts_real {Parameter 'SourceDataset_PATH' must be given a value.}; exit 1; }; ]
INCLUDE [ if {{$(DestDataset_POSTGRES)} == {}} { puts_real {Parameter 'DestDataset_POSTGRES' must be given a value.}; exit 1; }; ]
INCLUDE [ if {{$(DestDataset_CSV)} == {}} { puts_real {Parameter 'DestDataset_CSV' must be given a value.}; exit 1; }; ]
INCLUDE [ if {{$(SourceDataset_FFS_3)} == {}} { puts_real {Parameter 'SourceDataset_FFS_3' must be given a value.}; exit 1; }; ]
INCLUDE [ if {{$(SourceDataset_CSV2)} == {}} { puts_real {Parameter 'SourceDataset_CSV2' must be given a value.}; exit 1; }; ]
INCLUDE [ if {{$(DestDataset_POSTGRES_3)} == {}} { puts_real {Parameter 'DestDataset_POSTGRES_3' must be given a value.}; exit 1; }; ]
#! START_HEADER
#! START_WB_HEADER
READER_TYPE MULTI_READER
MULTI_READER_TYPE{0} PATH
MULTI_READER_KEYWORD{0} PATH_1
MULTI_READER_GEN_DIRECTIVES{0} TYPE,FILE,_MERGE_SCHEMAS,YES,RETRIEVE_FILE_PROPERTIES,YES,GLOB_PATTERN,*.csv
MULTI_READER_TYPE{1} FFS
MULTI_READER_KEYWORD{1} FFS_1
MULTI_READER_GEN_DIRECTIVES{1} PASSPHRASE,,SEARCH_CLOSEST_POINT,,SEARCH_ENVELOPE_COORDINATE_SYSTEM,,SEARCH_ENVELOPE_MINY,0,CLIP_TO_ENVELOPE,NO,_MERGE_SCHEMAS,YES,SEARCH_ENVELOPE_MAXY,0,EXPOSE_ATTRS_GROUP,,SEARCH_ENVELOPE_MAXX,0,SEARCH_ENVELOPE_MINX,0,FFS_EXPOSE_FORMAT_ATTRS,,USE_SEARCH_ENVELOPE,NO,FFS_SPATIAL_INDEXES,
MULTI_READER_TYPE{2} CSV2
MULTI_READER_KEYWORD{2} CSV2_1
MULTI_READER_GEN_DIRECTIVES{2} DELIMITER,<lt>comma<gt>,TRIM_FIELD_NAME_QUALIFIERS,Yes,ENCODING,,DATASET_GROUP,,ENCODING_GROUP,,TRIM_FIELD_VALUE_QUALIFIERS,Yes,FIELD_VALUES_GROUP,,_MERGE_SCHEMAS,YES,FEATURE_TYPE_NAME,FORMAT_NAME,SCHEMA_GROUP,,CASE_SENSITIVE_FIELD_NAMES,Yes,DATA_START_LINE,2,FIELD_SEPARATION_GROUP,,SKIPPED_LINES_GROUP,,USE_CUSTOM_SCHEMA,NO,ADVANCED_GROUP,,EXPOSE_ATTRS_GROUP,,CSV2_EXPOSE_FORMAT_ATTRS,,FIELDS_GROUP,,SKIP_DUPLICATE_DELIMITERS,No,FIELD_NAMES_GROUP,,PRESERVE_SOURCE_ENCODING,No,PREVIEW_GROUP,,FIELD_NAMES_LINE,1,READ_SKIPPED_LINES,No,ENFORCE_STRICT_SCHEMA,No,FIELD_QUALIFIER_CHARACTER,<lt>quote<gt>,SCAN_ADDITIONAL_FIELDS,No,PREVIEW_PLACEHOLDER,,SCHEMA_GENERATION_GROUP,,SCAN_MAX_ROWS,1000,SCAN_TYPES,No,FIELD_QUALIFIER_ESCAPE_CHARACTER,<lt>quote<gt>,SCHEMA,
WRITER_TYPE MULTI_WRITER
MULTI_WRITER_DATASET_ORDER BY_ID
MULTI_WRITER_FIRST_WRITER_ID 0
MULTI_WRITER_TYPE{0} POSTGRES
MULTI_WRITER_KEYWORD{0} POSTGRES_1
MULTI_WRITER_TYPE{1} CSV
MULTI_WRITER_KEYWORD{1} CSV_1
MULTI_WRITER_TYPE{2} POSTGRES
MULTI_WRITER_KEYWORD{2} POSTGRES_2
#! END_WB_HEADER
#! START_WB_HEADER
MACRO WB_KEYWORD "PATH_1"
#! END_WB_HEADER
#! START_SOURCE_HEADER PATH PATH_1
# =============================================================================
DEFAULT_MACRO PATH_IN_GLOB_PATTERN_PATH_1 *.csv
PATH_1_GLOB_PATTERN "$(PATH_IN_GLOB_PATTERN_PATH_1)"
GUI OPTIONAL TEXT_ENCODED PATH_IN_GLOB_PATTERN_PATH_1 Path Filter:
# =============================================================================
DEFAULT_MACRO PATH_IN_TYPE_PATH_1 FILE
PATH_1_TYPE "$(PATH_IN_TYPE_PATH_1)"
GUI CHOICE PATH_IN_TYPE_PATH_1 ANY%DIRECTORY%FILE Allowed Path Type:
# =============================================================================
DEFAULT_MACRO PATH_IN_RETRIEVE_FILE_PROPERTIES_PATH_1 NO
PATH_1_RETRIEVE_FILE_PROPERTIES "$(PATH_IN_RETRIEVE_FILE_PROPERTIES_PATH_1)"
GUI CHOICE PATH_IN_RETRIEVE_FILE_PROPERTIES_PATH_1 YES%NO Retrieve file properties:
# =====================================================================
# The following GUI line prompts for the folder from which to
# read
# The dataset this mapping file was generated from was:
#! END_SOURCE_HEADER
#! START_WB_HEADER
DEFAULT_MACRO SourceDataset
INCLUDE [ if {{$(SourceDataset)} != ""} {                        \
 puts {DEFAULT_MACRO SourceDataset_PATH_1 $(SourceDataset)}     \
 } ]
#! END_WB_HEADER
#! START_SOURCE_HEADER PATH PATH_1
DEFAULT_MACRO SourceDataset_PATH_1 $(SourceDataset_PATH)
GUI MULTIDIR SourceDataset_PATH_1 Source Folder and File Pathnames Folder:
# ===========================================================================
DEFAULT_MACRO PATH_IN_NETWORK_AUTHENTICATION_PATH_1 
PATH_1_NETWORK_AUTHENTICATION "$(PATH_IN_NETWORK_AUTHENTICATION_PATH_1)"
GUI OPTIONAL AUTHENTICATOR PATH_IN_NETWORK_AUTHENTICATION_PATH_1 CONTAINER%GROUP%CONTAINER_TITLE%"Network Authentication"%PROMPT_TYPE%NETWORK Network Authentication
# ===========================================================================
DEFAULT_MACRO PATH_IN_ATTRIBUTE_READING_PATH_1 ALL
PATH_1_ATTRIBUTE_READING "$(PATH_IN_ATTRIBUTE_READING_PATH_1)"
PATH_1_DATASET "$(SourceDataset_PATH_1)"
PATH_1_GENERATE_FME_BUILD_NUM 16492
#! END_SOURCE_HEADER
#! START_WB_HEADER
MACRO WB_KEYWORD "FFS_1"
#! END_WB_HEADER
#! START_SOURCE_HEADER FFS FFS_1
# ============================================================================
# The following GUI line prompts for the Feature Store file to be read
# The dataset this mapping file was generated from was:
#! END_SOURCE_HEADER
#! START_WB_HEADER
DEFAULT_MACRO SourceDataset
INCLUDE [ if {{$(SourceDataset)} != ""} {                        \
 puts {DEFAULT_MACRO SourceDataset_FFS_1 $(SourceDataset)}     \
 } ]
#! END_WB_HEADER
#! START_SOURCE_HEADER FFS FFS_1
DEFAULT_MACRO SourceDataset_FFS_1 $(SourceDataset_FFS_3)
GUI MULTIFILE SourceDataset_FFS_1 FME_Feature_Store_Files(*.ffs)|*.ffs|All_Files|* Source FME Feature Store (FFS) File(s):
# ============================================================================
# Set the passphrase (which is optional)
DEFAULT_MACRO FFS_IN_PASSPHRASE_FFS_1 
FFS_1_PASSPHRASE "$(FFS_IN_PASSPHRASE_FFS_1)"
GUI OPTIONAL PASSWORD_ENCODED FFS_IN_PASSPHRASE_FFS_1 Password:
DEFAULT_MACRO FFS_IN_EXPOSE_ATTRS_GROUP_FFS_1 
FFS_1_EXPOSE_ATTRS_GROUP "$(FFS_IN_EXPOSE_ATTRS_GROUP_FFS_1)"
GUI OPTIONAL DISCLOSUREGROUP FFS_IN_EXPOSE_ATTRS_GROUP_FFS_1 FFS_EXPOSE_FORMAT_ATTRS Schema Attributes
DEFAULT_MACRO FFS_IN_FFS_SPATIAL_INDEXES_FFS_1 
GUI OPTIONAL DISCLOSUREGROUP FFS_IN_FFS_SPATIAL_INDEXES_FFS_1 SEARCH_CLOSEST_POINT Spatial Indexes
# If desired, the below string can specify a point, and the closest feature
# in the FFS file will be read and returned.
DEFAULT_MACRO FFS_IN_SEARCH_CLOSEST_POINT_FFS_1 
FFS_1_SEARCH_CLOSEST_POINT "$(FFS_IN_SEARCH_CLOSEST_POINT_FFS_1)"
GUI OPTIONAL TEXT FFS_IN_SEARCH_CLOSEST_POINT_FFS_1 Closest Search Point
# Include this file in source setting section to add native search envelope processing
# Zero as a default means we don't do any search -- this makes workbench happier
# ===========================================================================
DEFAULT_MACRO FFS_IN_SEARCH_ENVELOPE_MINX_FFS_1 0
FFS_1_SEARCH_ENVELOPE "$(FFS_IN_SEARCH_ENVELOPE_MINX_FFS_1)"
GUI OPTIONAL FLOAT FFS_IN_SEARCH_ENVELOPE_MINX_FFS_1 Minimum X:
# ===========================================================================
DEFAULT_MACRO FFS_IN_SEARCH_ENVELOPE_MINY_FFS_1 0
FFS_1_SEARCH_ENVELOPE "$(FFS_IN_SEARCH_ENVELOPE_MINY_FFS_1)"
GUI OPTIONAL FLOAT FFS_IN_SEARCH_ENVELOPE_MINY_FFS_1 Minimum Y:
# ===========================================================================
DEFAULT_MACRO FFS_IN_SEARCH_ENVELOPE_MAXX_FFS_1 0
FFS_1_SEARCH_ENVELOPE "$(FFS_IN_SEARCH_ENVELOPE_MAXX_FFS_1)"
GUI OPTIONAL FLOAT FFS_IN_SEARCH_ENVELOPE_MAXX_FFS_1 Maximum X:
# ===========================================================================
DEFAULT_MACRO FFS_IN_SEARCH_ENVELOPE_MAXY_FFS_1 0
FFS_1_SEARCH_ENVELOPE "$(FFS_IN_SEARCH_ENVELOPE_MAXY_FFS_1)"
GUI OPTIONAL FLOAT FFS_IN_SEARCH_ENVELOPE_MAXY_FFS_1 Maximum Y:
# ===========================================================================
DEFAULT_MACRO FFS_IN_SEARCH_ENVELOPE_COORDINATE_SYSTEM_FFS_1 
FFS_1_SEARCH_ENVELOPE "$(FFS_IN_SEARCH_ENVELOPE_COORDINATE_SYSTEM_FFS_1)"
GUI OPTIONAL COORDSYS FFS_IN_SEARCH_ENVELOPE_COORDINATE_SYSTEM_FFS_1 Search Envelope Coordinate System:
# ===========================================================================
DEFAULT_MACRO FFS_IN_CLIP_TO_ENVELOPE_FFS_1 NO
FFS_1_CLIP_TO_ENVELOPE "$(FFS_IN_CLIP_TO_ENVELOPE_FFS_1)"
GUI OPTIONAL CHECKBOX FFS_IN_CLIP_TO_ENVELOPE_FFS_1 YES%NO Clip to Search Envelope
# By default, strip FME meta-attributes (likemulti_reader_keyword) from
# the features the FFS reader creates.
FFS_1_STRIP_META_ATTRS YES
# By default, ignore spillover files (*_1.ffs,*_2.ffs,etc).
# When enabled, these files will be ignored by the reader, and only read when
# *.ffs itself is read.
FFS_1_ENFORCE_SECONDARY_FILE_NAMES YES
# ===========================================================================
DEFAULT_MACRO FFS_IN_NETWORK_AUTHENTICATION_FFS_1 
FFS_1_NETWORK_AUTHENTICATION "$(FFS_IN_NETWORK_AUTHENTICATION_FFS_1)"
GUI OPTIONAL AUTHENTICATOR FFS_IN_NETWORK_AUTHENTICATION_FFS_1 CONTAINER%GROUP%CONTAINER_TITLE%"Network Authentication"%PROMPT_TYPE%NETWORK Network Authentication
# ===========================================================================
DEFAULT_MACRO FFS_IN_ATTRIBUTE_READING_FFS_1 ALL
FFS_1_ATTRIBUTE_READING "$(FFS_IN_ATTRIBUTE_READING_FFS_1)"
FFS_1_DATASET "$(SourceDataset_FFS_1)"
FFS_1_GENERATE_FME_BUILD_NUM 17271
#! END_SOURCE_HEADER
#! START_WB_HEADER
MACRO WB_KEYWORD "CSV2_1"
#! END_WB_HEADER
#! START_SOURCE_HEADER CSV2 CSV2_1
# =====================================================================
# The following GUI line prompts for a file to be used as the source CSV file.
# The user input is stored in a macro, which is then used to define
# the dataset to be read.
# The dataset this mapping file was generated from was:
#! END_SOURCE_HEADER
#! START_WB_HEADER
DEFAULT_MACRO SourceDataset
INCLUDE [ if {{$(SourceDataset)} != ""} {                        \
 puts {DEFAULT_MACRO SourceDataset_CSV2_1 $(SourceDataset)}     \
 } ]
#! END_WB_HEADER
#! START_SOURCE_HEADER CSV2 CSV2_1
DEFAULT_MACRO SourceDataset_CSV2_1 $(SourceDataset_CSV2)
GUI MULTIFILE SourceDataset_CSV2_1 CSV/Compressed_CSV/TEXT_Files(*.csv;*.gz;*.txt)|*.csv;*.gz;*.txt|CSV_Files(*.csv)|*.csv|Compressed_CSV_Files(*.gz)|*.gz|Text_Files(*.txt)|*.txt|All_Files|* Source CSV (Comma Separated Value) File(s):
DEFAULT_MACRO CSV2_IN_DATASET_GROUP_CSV2_1 
GUI OPTIONAL DISCLOSUREGROUP CSV2_IN_DATASET_GROUP_CSV2_1 FME_DISCLOSURE_OPEN%FEATURE_TYPE_NAME Dataset Parameters
DEFAULT_MACRO CSV2_IN_FEATURE_TYPE_NAME_CSV2_1 FORMAT_NAME
CSV2_1_FEATURE_TYPE_NAME "$(CSV2_IN_FEATURE_TYPE_NAME_CSV2_1)"
DEFAULT_MACRO CSV2_IN_FIELDS_GROUP_CSV2_1 
GUI OPTIONAL DISCLOSUREGROUP CSV2_IN_FIELDS_GROUP_CSV2_1 FME_DISCLOSURE_OPEN%DELIMITER%FIELD_NAMES_LINE%DATA_START_LINE Fields
DEFAULT_MACRO CSV2_IN_DELIMITER_CSV2_1 <comma>
CSV2_1_DELIMITER "$(CSV2_IN_DELIMITER_CSV2_1)"
GUI STRING_OR_CHOICE_ENCODED CSV2_IN_DELIMITER_CSV2_1 ,%;%|%space%tab Delimiter Character:
DEFAULT_MACRO CSV2_IN_FIELD_NAMES_LINE_CSV2_1 1
CSV2_1_FIELD_NAMES_LINE "$(CSV2_IN_FIELD_NAMES_LINE_CSV2_1)"
GUI OPTIONAL RANGE_SLIDER CSV2_IN_FIELD_NAMES_LINE_CSV2_1 1%MAX%0 Field Names Line:
DEFAULT_MACRO CSV2_IN_DATA_START_LINE_CSV2_1 2
CSV2_1_DATA_START_LINE "$(CSV2_IN_DATA_START_LINE_CSV2_1)"
GUI RANGE_SLIDER CSV2_IN_DATA_START_LINE_CSV2_1 1%MAX%0 Data Start Line:
DEFAULT_MACRO CSV2_IN_ADVANCED_GROUP_CSV2_1 
GUI OPTIONAL DISCLOSUREGROUP CSV2_IN_ADVANCED_GROUP_CSV2_1 FME_DISCLOSURE_CLOSED%FIELD_SEPARATION_GROUP%FIELD_NAMES_GROUP%FIELD_VALUES_GROUP%ENCODING_GROUP%SKIPPED_LINES_GROUP%SCHEMA_GENERATION_GROUP Advanced
DEFAULT_MACRO CSV2_IN_FIELD_SEPARATION_GROUP_CSV2_1 
GUI OPTIONAL DISCLOSUREGROUP CSV2_IN_FIELD_SEPARATION_GROUP_CSV2_1 FME_DISCLOSURE_CLOSED%SKIP_DUPLICATE_DELIMITERS%FIELD_QUALIFIER_CHARACTER%FIELD_QUALIFIER_ESCAPE_CHARACTER Field Separation
DEFAULT_MACRO CSV2_IN_SKIP_DUPLICATE_DELIMITERS_CSV2_1 No
CSV2_1_SKIP_DUPLICATE_DELIMITERS "$(CSV2_IN_SKIP_DUPLICATE_DELIMITERS_CSV2_1)"
GUI CHOICE CSV2_IN_SKIP_DUPLICATE_DELIMITERS_CSV2_1 Yes%No Skip Duplicate Delimiters:
DEFAULT_MACRO CSV2_IN_FIELD_QUALIFIER_CHARACTER_CSV2_1 <quote>
CSV2_1_FIELD_QUALIFIER_CHARACTER "$(CSV2_IN_FIELD_QUALIFIER_CHARACTER_CSV2_1)"
GUI OPTIONAL STRING_ENCODED CSV2_IN_FIELD_QUALIFIER_CHARACTER_CSV2_1 Field Qualifier Character:
DEFAULT_MACRO CSV2_IN_FIELD_QUALIFIER_ESCAPE_CHARACTER_CSV2_1 <quote>
CSV2_1_FIELD_QUALIFIER_ESCAPE_CHARACTER "$(CSV2_IN_FIELD_QUALIFIER_ESCAPE_CHARACTER_CSV2_1)"
GUI OPTIONAL STRING_ENCODED CSV2_IN_FIELD_QUALIFIER_ESCAPE_CHARACTER_CSV2_1 Field Qualifier Escape Character:
DEFAULT_MACRO CSV2_IN_FIELD_NAMES_GROUP_CSV2_1 
GUI OPTIONAL DISCLOSUREGROUP CSV2_IN_FIELD_NAMES_GROUP_CSV2_1 FME_DISCLOSURE_CLOSED%CASE_SENSITIVE_FIELD_NAMES%ENFORCE_STRICT_SCHEMA Field Names
DEFAULT_MACRO CSV2_IN_TRIM_FIELD_NAME_QUALIFIERS_CSV2_1 Yes
CSV2_1_TRIM_FIELD_NAME_QUALIFIERS "$(CSV2_IN_TRIM_FIELD_NAME_QUALIFIERS_CSV2_1)"
DEFAULT_MACRO CSV2_IN_CASE_SENSITIVE_FIELD_NAMES_CSV2_1 Yes
CSV2_1_CASE_SENSITIVE_FIELD_NAMES "$(CSV2_IN_CASE_SENSITIVE_FIELD_NAMES_CSV2_1)"
GUI CHOICE CSV2_IN_CASE_SENSITIVE_FIELD_NAMES_CSV2_1 Yes%No Case Sensitive Field Names:
DEFAULT_MACRO CSV2_IN_ENFORCE_STRICT_SCHEMA_CSV2_1 No
CSV2_1_ENFORCE_STRICT_SCHEMA "$(CSV2_IN_ENFORCE_STRICT_SCHEMA_CSV2_1)"
GUI CHOICE CSV2_IN_ENFORCE_STRICT_SCHEMA_CSV2_1 Yes%No Enforce Strict Schema:
DEFAULT_MACRO CSV2_IN_FIELD_VALUES_GROUP_CSV2_1 
GUI OPTIONAL DISCLOSUREGROUP CSV2_IN_FIELD_VALUES_GROUP_CSV2_1 FME_DISCLOSURE_CLOSED%TRIM_FIELD_VALUE_QUALIFIERS Field Values
DEFAULT_MACRO CSV2_IN_TRIM_FIELD_VALUE_QUALIFIERS_CSV2_1 Yes
CSV2_1_TRIM_FIELD_VALUE_QUALIFIERS "$(CSV2_IN_TRIM_FIELD_VALUE_QUALIFIERS_CSV2_1)"
GUI CHOICE CSV2_IN_TRIM_FIELD_VALUE_QUALIFIERS_CSV2_1 Yes%No Trim Field Qualifier Characters:
DEFAULT_MACRO CSV2_IN_ENCODING_GROUP_CSV2_1 
GUI OPTIONAL DISCLOSUREGROUP CSV2_IN_ENCODING_GROUP_CSV2_1 FME_DISCLOSURE_CLOSED%ENCODING%PRESERVE_SOURCE_ENCODING Encoding
DEFAULT_MACRO CSV2_IN_ENCODING_CSV2_1 
CSV2_1_ENCODING "$(CSV2_IN_ENCODING_CSV2_1)"
GUI OPTIONAL STRING_OR_ENCODING CSV2_IN_ENCODING_CSV2_1 SYSTEM%* Character Encoding:
DEFAULT_MACRO CSV2_IN_PRESERVE_SOURCE_ENCODING_CSV2_1 No
CSV2_1_PRESERVE_SOURCE_ENCODING "$(CSV2_IN_PRESERVE_SOURCE_ENCODING_CSV2_1)"
GUI CHOICE CSV2_IN_PRESERVE_SOURCE_ENCODING_CSV2_1 Yes%No Preserve Source Encoding:
DEFAULT_MACRO CSV2_IN_SKIPPED_LINES_GROUP_CSV2_1 
GUI OPTIONAL DISCLOSUREGROUP CSV2_IN_SKIPPED_LINES_GROUP_CSV2_1 FME_DISCLOSURE_CLOSED%READ_SKIPPED_LINES Skipped Lines
DEFAULT_MACRO CSV2_IN_READ_SKIPPED_LINES_CSV2_1 No
CSV2_1_READ_SKIPPED_LINES "$(CSV2_IN_READ_SKIPPED_LINES_CSV2_1)"
GUI CHOICE CSV2_IN_READ_SKIPPED_LINES_CSV2_1 Yes%No Read Skipped Lines:
DEFAULT_MACRO CSV2_IN_SCHEMA_GENERATION_GROUP_CSV2_1 
GUI OPTIONAL DISCLOSUREGROUP CSV2_IN_SCHEMA_GENERATION_GROUP_CSV2_1 FME_DISCLOSURE_CLOSED%SCAN_MAX_ROWS%SCAN_TYPES%SCAN_ADDITIONAL_FIELDS Schema Generation
DEFAULT_MACRO CSV2_IN_SCAN_MAX_ROWS_CSV2_1 1000
CSV2_1_SCAN_MAX_ROWS "$(CSV2_IN_SCAN_MAX_ROWS_CSV2_1)"
DEFAULT_MACRO CSV2_IN_SCAN_TYPES_CSV2_1 No
CSV2_1_SCAN_TYPES "$(CSV2_IN_SCAN_TYPES_CSV2_1)"
DEFAULT_MACRO CSV2_IN_SCAN_ADDITIONAL_FIELDS_CSV2_1 No
CSV2_1_SCAN_ADDITIONAL_FIELDS "$(CSV2_IN_SCAN_ADDITIONAL_FIELDS_CSV2_1)"
DEFAULT_MACRO CSV2_IN_EXPOSE_ATTRS_GROUP_CSV2_1 
CSV2_1_EXPOSE_ATTRS_GROUP "$(CSV2_IN_EXPOSE_ATTRS_GROUP_CSV2_1)"
GUI OPTIONAL DISCLOSUREGROUP CSV2_IN_EXPOSE_ATTRS_GROUP_CSV2_1 CSV2_EXPOSE_FORMAT_ATTRS Schema Attributes
# ===========================================================================
DEFAULT_MACRO CSV2_IN_NETWORK_AUTHENTICATION_CSV2_1 
CSV2_1_NETWORK_AUTHENTICATION "$(CSV2_IN_NETWORK_AUTHENTICATION_CSV2_1)"
GUI OPTIONAL AUTHENTICATOR CSV2_IN_NETWORK_AUTHENTICATION_CSV2_1 CONTAINER%GROUP%CONTAINER_TITLE%"Network Authentication"%PROMPT_TYPE%NETWORK Network Authentication
# ===========================================================================
DEFAULT_MACRO CSV2_IN_ATTRIBUTE_READING_CSV2_1 DEFLINE
CSV2_1_ATTRIBUTE_READING "$(CSV2_IN_ATTRIBUTE_READING_CSV2_1)"
CSV2_1_DATASET "$(SourceDataset_CSV2_1)"
CSV2_1_GENERATE_FME_BUILD_NUM 17271
#! END_SOURCE_HEADER
#! START_WB_HEADER
MACRO WB_KEYWORD "POSTGRES_1"
#! END_WB_HEADER
#! START_DEST_HEADER POSTGRES POSTGRES_1
#! END_DEST_HEADER
#! START_WB_HEADER
DEFAULT_MACRO DestDataset
INCLUDE [ if {"$(DestDataset)" != ""} {                          \
 puts {DEFAULT_MACRO DestDataset_POSTGRES_1 $(DestDataset)}         \
 } ]
#! END_WB_HEADER
#! START_DEST_HEADER POSTGRES POSTGRES_1
DEFAULT_MACRO DestDataset_POSTGRES_1 $(DestDataset_POSTGRES)
GUI NAMED_DB_CONNECTION_ENCODED DestDataset_POSTGRES_1 FMT:POSTGRES Connection:
# ============================================================================
# Opt in for destination dataset type vs format type validation
DEFAULT_MACRO POSTGRES_OUT_DESTINATION_DATASETTYPE_VALIDATION_POSTGRES_1 Yes
POSTGRES_1_DESTINATION_DATASETTYPE_VALIDATION "$(POSTGRES_OUT_DESTINATION_DATASETTYPE_VALIDATION_POSTGRES_1)"
DEFAULT_MACRO POSTGRES_OUT_WRITER_MODE_POSTGRES_1 INSERT
GUI CHOICE POSTGRES_OUT_WRITER_MODE_POSTGRES_1 INSERT%UPDATE%DELETE Writer Mode:
POSTGRES_1_WRITER_MODE $(POSTGRES_OUT_WRITER_MODE_POSTGRES_1)
DEFAULT_MACRO POSTGRES_OUT_START_TRANSACTION_POSTGRES_1 0
GUI TEXT POSTGRES_OUT_START_TRANSACTION_POSTGRES_1 Starting Feature:
POSTGRES_1_START_TRANSACTION $(POSTGRES_OUT_START_TRANSACTION_POSTGRES_1)
DEFAULT_MACRO POSTGRES_OUT_TRANSACTION_INTERVAL_POSTGRES_1 5000
GUI TEXT POSTGRES_OUT_TRANSACTION_INTERVAL_POSTGRES_1 Features Per Transaction:
POSTGRES_1_TRANSACTION_INTERVAL $(POSTGRES_OUT_TRANSACTION_INTERVAL_POSTGRES_1)
DEFAULT_MACRO POSTGRES_OUT_BULK_COPY_POSTGRES_1 YES
GUI CHOICE POSTGRES_OUT_BULK_COPY_POSTGRES_1 YES%NO Bulk Copy Insert:
POSTGRES_1_BULK_COPY $(POSTGRES_OUT_BULK_COPY_POSTGRES_1)
DEFAULT_MACRO POSTGRES_OUT_BEGIN_SQL_POSTGRES_1 
GUI OPTIONAL TEXT_EDIT_SQL POSTGRES_OUT_BEGIN_SQL_POSTGRES_1 SQL Statement to Execute Before Translation:
POSTGRES_1_BEGIN_SQL "$(POSTGRES_OUT_BEGIN_SQL_POSTGRES_1)"
DEFAULT_MACRO POSTGRES_OUT_END_SQL_POSTGRES_1 
GUI OPTIONAL TEXT_EDIT_SQL POSTGRES_OUT_END_SQL_POSTGRES_1 SQL Statement to Execute After Translation:
POSTGRES_1_END_SQL "$(POSTGRES_OUT_END_SQL_POSTGRES_1)"
POSTGRES_1_DATASET "$(DestDataset_POSTGRES_1)"
POSTGRES_1_GENERATE_FME_BUILD_NUM 15570
#! END_DEST_HEADER
#! START_WB_HEADER
MACRO WB_KEYWORD "CSV_1"
#! END_WB_HEADER
#! START_DEST_HEADER CSV CSV_1
# ============================================================================
# The following GUI line prompts for a folder where the
# CSV files will be stored
#! END_DEST_HEADER
#! START_WB_HEADER
DEFAULT_MACRO DestDataset
INCLUDE [ if {"$(DestDataset)" != ""} {                          \
 puts {DEFAULT_MACRO DestDataset_CSV_1 $(DestDataset)}         \
 } ]
#! END_WB_HEADER
#! START_DEST_HEADER CSV CSV_1
DEFAULT_MACRO DestDataset_CSV_1 $(DestDataset_CSV)
GUI DIRNAME DestDataset_CSV_1 Destination CSV (Comma Separated Value) Folder:
CSV_1_PLUGIN_MAX_CHANNELS 100
CSV_1_ALLOW_TYPE_TRUNCATION yes
CSV_1_PERMISSIVE_TYPES yes
# ============================================================================
# The following determines the extension for output CSV files
DEFAULT_MACRO CSV_OUT_EXTENSION_CSV_1 csv
CSV_1_EXTENSION "$(CSV_OUT_EXTENSION_CSV_1)"
GUI OPTIONAL TEXT CSV_OUT_EXTENSION_CSV_1 Extension:
# =====================================================================
# Allows one to append
DEFAULT_MACRO CSV_OUT_APPEND_CSV_1 No
CSV_1_APPEND "$(CSV_OUT_APPEND_CSV_1)"
GUI OPTIONAL CHECKBOX CSV_OUT_APPEND_CSV_1 Yes%No Append to File:
# ============================================================================
# The following determines whether field names will be written on
# the first row of the file.
DEFAULT_MACRO CSV_OUT_FIELD_NAMES_CSV_1 yes
CSV_1_FIELD_NAMES "$(CSV_OUT_FIELD_NAMES_CSV_1)"
GUI OPTIONAL CHECKBOX CSV_OUT_FIELD_NAMES_CSV_1 yes%no Output Field Names on First Line:
# ============================================================================
# Write out schema.ini file (PR#58638)
DEFAULT_MACRO CSV_OUT_WRITE_SCHEMA_FILE_CSV_1 no
CSV_1_WRITE_SCHEMA_FILE "$(CSV_OUT_WRITE_SCHEMA_FILE_CSV_1)"
GUI ACTIVECHOICE CSV_OUT_WRITE_SCHEMA_FILE_CSV_1 yes%no,CSV_OUT_PREPEND_SCHEMA_FILE Write Schema Configuration File
# ============================================================================
# Allows for appending to existing schema.ini file (PR#58638)
DEFAULT_MACRO CSV_OUT_PREPEND_SCHEMA_FILE_CSV_1 <Unused>
CSV_1_PREPEND_SCHEMA_FILE "$(CSV_OUT_PREPEND_SCHEMA_FILE_CSV_1)"
GUI CHOICE CSV_OUT_PREPEND_SCHEMA_FILE_CSV_1 yes%no Prepend To Existing Schema Configuration File
# ============================================================================
# The following determines the field seperator
# PR#19714 Changed GUI LOOKUP to STRING_OR_CHOICE for showing space and tab
# as explicit delimiters for parsing issues and symmetry with the reader.
DEFAULT_MACRO CSV_OUT_SEPARATOR_CSV_1 ,
CSV_1_SEPARATOR "$(CSV_OUT_SEPARATOR_CSV_1)"
GUI OPTIONAL STRING_OR_CHOICE CSV_OUT_SEPARATOR_CSV_1 ,%;%|%space%tab Separator Character:
# =====================================================================
# Allows to set one of the character encodings for output file
DEFAULT_MACRO CSV_OUT_ENCODING_CSV_1 
CSV_1_ENCODING "$(CSV_OUT_ENCODING_CSV_1)"
GUI OPTIONAL STRING_OR_ENCODING CSV_OUT_ENCODING_CSV_1 SYSTEM%* Character Encoding:
# =====================================================================
# PR 15909
# The following choice determines if the byte order mark should be written
# when using UTF-8 encoding. By default BOM is written, so _WRITE_UTF8_BOM should be yes.
DEFAULT_MACRO CSV_OUT_WRITE_UTF8_BOM_CSV_1 yes
CSV_1_WRITE_UTF8_BOM "$(CSV_OUT_WRITE_UTF8_BOM_CSV_1)"
GUI CHOICE CSV_OUT_WRITE_UTF8_BOM_CSV_1 yes%no Write UTF-8 Byte Order Mark
# ============================================================================
# Opt in for destination dataset type vs format type validation
DEFAULT_MACRO CSV_OUT_DESTINATION_DATASETTYPE_VALIDATION_CSV_1 Yes
CSV_1_DESTINATION_DATASETTYPE_VALIDATION "$(CSV_OUT_DESTINATION_DATASETTYPE_VALIDATION_CSV_1)"
# =====================================================================
DEFAULT_MACRO CSV_OUT_QUOTE_OUTPUT_CSV_1 if_needed
CSV_1_QUOTE_OUTPUT "$(CSV_OUT_QUOTE_OUTPUT_CSV_1)"
GUI CHOICE CSV_OUT_QUOTE_OUTPUT_CSV_1 yes%if_needed%no Quote Output Values:
DEFAULT_MACRO CSV_OUT_QUOTE_FIELD_NAMES_CSV_1 no
CSV_1_QUOTE_FIELD_NAMES "$(CSV_OUT_QUOTE_FIELD_NAMES_CSV_1)"
GUI CHOICE CSV_OUT_QUOTE_FIELD_NAMES_CSV_1 yes%no Quote Field Names:
DEFAULT_MACRO CSV_OUT_END_OF_LINE_CSV_1 
CSV_1_END_OF_LINE "$(CSV_OUT_END_OF_LINE_CSV_1)"
GUI OPTIONAL CHOICE CSV_OUT_END_OF_LINE_CSV_1 Windows%Unix%Macintosh Line Termination:
CSV_1_DATASET "$(DestDataset_CSV_1)"
CSV_1_GENERATE_FME_BUILD_NUM 16492
#! END_DEST_HEADER
#! START_WB_HEADER
MACRO WB_KEYWORD "POSTGRES_2"
#! END_WB_HEADER
#! START_DEST_HEADER POSTGRES POSTGRES_2
#! END_DEST_HEADER
#! START_WB_HEADER
DEFAULT_MACRO DestDataset
INCLUDE [ if {"$(DestDataset)" != ""} {                          \
 puts {DEFAULT_MACRO DestDataset_POSTGRES_2 $(DestDataset)}         \
 } ]
#! END_WB_HEADER
#! START_DEST_HEADER POSTGRES POSTGRES_2
DEFAULT_MACRO DestDataset_POSTGRES_2 $(DestDataset_POSTGRES_3)
GUI NAMED_DB_CONNECTION_ENCODED DestDataset_POSTGRES_2 FMT:POSTGRES Connection:
DEFAULT_MACRO POSTGRES_OUT_WRITER_MODE_POSTGRES_2 INSERT
DEFAULT_MACRO POSTGRES_OUT_START_TRANSACTION_POSTGRES_2 0
GUI TEXT POSTGRES_OUT_START_TRANSACTION_POSTGRES_2 Starting Feature:
POSTGRES_2_START_TRANSACTION $(POSTGRES_OUT_START_TRANSACTION_POSTGRES_2)
DEFAULT_MACRO POSTGRES_OUT_TRANSACTION_INTERVAL_POSTGRES_2 1000
GUI TEXT POSTGRES_OUT_TRANSACTION_INTERVAL_POSTGRES_2 Features Per Transaction:
POSTGRES_2_TRANSACTION_INTERVAL $(POSTGRES_OUT_TRANSACTION_INTERVAL_POSTGRES_2)
DEFAULT_MACRO POSTGRES_OUT_BULK_COPY_POSTGRES_2 YES
GUI CHOICE POSTGRES_OUT_BULK_COPY_POSTGRES_2 YES%NO Bulk Insert:
POSTGRES_2_BULK_COPY $(POSTGRES_OUT_BULK_COPY_POSTGRES_2)
DEFAULT_MACRO POSTGRES_OUT_BEGIN_SQL_POSTGRES_2 
GUI OPTIONAL TEXT_EDIT_SQL_CFG POSTGRES_OUT_BEGIN_SQL_POSTGRES_2 MODE,SQL;FORMAT,POSTGRES SQL Statement to Execute Before Translation:
POSTGRES_2_BEGIN_SQL "$(POSTGRES_OUT_BEGIN_SQL_POSTGRES_2)"
DEFAULT_MACRO POSTGRES_OUT_END_SQL_POSTGRES_2 
GUI OPTIONAL TEXT_EDIT_SQL_CFG POSTGRES_OUT_END_SQL_POSTGRES_2 MODE,SQL;FORMAT,POSTGRES SQL Statement to Execute After Translation:
POSTGRES_2_END_SQL "$(POSTGRES_OUT_END_SQL_POSTGRES_2)"
POSTGRES_2_DATASET "$(DestDataset_POSTGRES_2)"
POSTGRES_2_GENERATE_FME_BUILD_NUM 16492
#! END_DEST_HEADER
#! START_WB_HEADER
#! END_WB_HEADER
#! END_HEADER

LOG_FILENAME "$(FME_MF_DIR)Load_DHS_Data_To_PG_With_Checks.log"
LOG_APPEND NO
LOG_FILTER_MASK -1
LOG_MAX_FEATURES 200
LOG_MAX_RECORDED_FEATURES 200
FME_REPROJECTION_ENGINE FME
FME_IMPLICIT_CSMAP_REPROJECTION_MODE Auto
FME_GEOMETRY_HANDLING Enhanced
FME_STROKE_MAX_DEVIATION 0
DEFAULT_MACRO DATASET_KEYWORD_PATH_1 PATH_1
DEFAULT_MACRO DATASET_KEYWORD_FFS_1 FFS_1
DEFAULT_MACRO DATASET_KEYWORD_CSV2_1 CSV2_1
DEFAULT_MACRO DATASET_KEYWORD_POSTGRES_1 POSTGRES_1
DEFAULT_MACRO DATASET_KEYWORD_CSV_1 CSV_1
DEFAULT_MACRO DATASET_KEYWORD_POSTGRES_2 POSTGRES_2
# -------------------------------------------------------------------------

PATH_1_READER_META_ATTRIBUTES fme_feature_type

# -------------------------------------------------------------------------

FFS_1_READER_META_ATTRIBUTES fme_feature_type

# -------------------------------------------------------------------------

CSV2_1_READER_META_ATTRIBUTES fme_feature_type

# -------------------------------------------------------------------------

MULTI_READER_CONTINUE_ON_READER_FAILURE No

# -------------------------------------------------------------------------

MACRO WORKSPACE_NAME Load_DHS_Data_To_PG_With_Checks
MACRO FME_VIEWER_APP fmedatainspector
# -------------------------------------------------------------------------

INCLUDE [ if {[info exists env(FME_TEMP)] && [file isdirectory $env(FME_TEMP)]} {set gVisualizerTemp $env(FME_TEMP)}  elseif {[info exists env(TEMP)] && [file isdirectory $env(TEMP)]}  {set gVisualizerTemp $env(TEMP)}  elseif { $tcl_platform(platform) == "unix" } {set gVisualizerTemp "/tmp"} else {set gVisualizerTemp c:};  regsub -all {[ ,&]} {$(WORKSPACE_NAME)} {_} wsname; set gVisualizerTemp $gVisualizerTemp/${wsname}_[clock format [clock seconds] -format %H%M%S];  puts "MACRO WORKSPACE_TEMP_DIR $gVisualizerTemp"; 
MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/inspector.ffs
MACRO VISUALIZER_SCHEMA_FILE $(WORKSPACE_TEMP_DIR)/inspector.fsc
MACRO VISUALIZER_CREATE_SPATIAL_INDEX YES
# -------------------------------------------------------------------------
FFS_1_DEF AllSchemas_20170410   RecordName                   varchar(7)   attribute{}.name             varchar(200)   attribute{}.fme_data_type    varchar(200)   attribute{}.StartMin         varchar(200)
# -------------------------------------------------------------------------
CSV2_1_DEF CSV   fme_attribute_reading        defined   maxlen                       string   name                         string   recordname                   string   surveyid                     string
# -------------------------------------------------------------------------

FACTORY_DEF * RoutingFactory   FACTORY_NAME "Router and Unexpected Input Remover"   COMMAND_PARM_EVALUATION SINGLE_PASS   INPUT FEATURE_TYPE *    ROUTE PATH PATH_1::PATH multi_reader_keyword,$(DATASET_KEYWORD_PATH_1) TO FME_GENERIC ::PATH ALIAS_GEOMETRY    ROUTE FFS FFS_1::AllSchemas_20170410 multi_reader_keyword,$(DATASET_KEYWORD_FFS_1) TO FME_GENERIC ::AllSchemas_20170410 ALIAS_GEOMETRY    ROUTE CSV2 CSV2_1::CSV multi_reader_keyword,$(DATASET_KEYWORD_CSV2_1) TO FME_GENERIC ::CSV ALIAS_GEOMETRY    MERGE_INPUT Yes   OUTPUT ROUTED FEATURE_TYPE *   OUTPUT NOT_ROUTED FEATURE_TYPE *     @LogCount("UnexpectedInput @FeatureType()")     @FeatureType(__TO_REMOVE__)
FACTORY_DEF * TeeFactory   FACTORY_NAME "Unexpected Input Remover Nuker"   INPUT FEATURE_TYPE __TO_REMOVE__
PATH_1_MERGE_DEF PATH_1::PATH EXACT PATH
FFS_1_MERGE_DEF FFS_1::AllSchemas_20170410 EXACT AllSchemas_20170410
CSV2_1_MERGE_DEF CSV2_1::CSV EXACT CSV
# -------------------------------------------------------------------------

FACTORY_DEF * TeeFactory    FACTORY_NAME "AllSchemas_20170410 (FFS_1) Splitter"    INPUT FEATURE_TYPE AllSchemas_20170410    OUTPUT FEATURE_TYPE AllSchemas_20170410_FFS_1
FACTORY_DEF * TeeFactory   FACTORY_NAME "AllSchemas_20170410_FFS_1 Feature Counter -1 43"   INPUT FEATURE_TYPE AllSchemas_20170410_FFS_1   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 43")
# -------------------------------------------------------------------------

FACTORY_DEF * TeeFactory    FACTORY_NAME "CSV (CSV2_1) Splitter"    INPUT FEATURE_TYPE CSV    OUTPUT FEATURE_TYPE CSV_CSV2_1
FACTORY_DEF * TeeFactory   FACTORY_NAME "CSV_CSV2_1 Feature Counter -1 44"   INPUT FEATURE_TYPE CSV_CSV2_1   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 44")
# -------------------------------------------------------------------------

FACTORY_DEF * TeeFactory    FACTORY_NAME "PATH (PATH_1) Splitter"    INPUT FEATURE_TYPE PATH    OUTPUT FEATURE_TYPE PATH_PATH_1
FACTORY_DEF * TeeFactory   FACTORY_NAME "PATH_PATH_1 Feature Counter -1 42"   INPUT FEATURE_TYPE PATH_PATH_1   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 42")
DEFAULT_MACRO WB_CURRENT_CONTEXT
# -------------------------------------------------------------------------
MACRO SQLCreator_DIRECTIVES SCHEMAS_FOR_TABLE_LISTING dhs_data_tables NAMED_CONNECTION DHS<space>Data<space>Readonly QUERY_FEATURE_TYPES_FOR_MERGE_FILTERS Yes
FACTORY_DEF * CreationFactory    FACTORY_NAME SQLCreator_Creator    OUTPUT FEATURE_TYPE _____CREATED______
FACTORY_DEF * QueryFactory    FACTORY_NAME SQLCreator    INPUT FEATURE_TYPE _____CREATED______    QUERY_SQL            SELECT<space>table_name<lf>FROM<space>information_schema.tables<lf>WHERE<space>table_schema<space>=<space><apos>dhs_data_tables<apos><lf>--<space>table_name<space>LIKE<space><apos>%REC%<apos>    COMBINE_ATTRIBUTES   RESULT_ONLY    COMBINE_GEOMETRY     RESULT_ONLY    READER_TYPE          POSTGRES    READER_DATASET       "DHS<space>Data<space>Readonly"    READER_PARAMS        $(SQLCreator_DIRECTIVES)    QUERYFCT_PROPAGATE_IDS_ON_SQL_EXECUTE YES    CONTINUE_ON_READER_ERROR YES    OUTPUT RESULT FEATURE_TYPE SQLCreator_RESULT        @SupplyAttributes(fme_feature_type,SQLCreator)    OUTPUT READER_ERROR FEATURE_TYPE SQLCreator_<REJECTED>
FACTORY_DEF * TeeFactory   FACTORY_NAME "SQLCreator RESULT Splitter"   INPUT FEATURE_TYPE SQLCreator_RESULT   OUTPUT FEATURE_TYPE SQLCreator_RESULT_0_sjsReQioa5E=   OUTPUT FEATURE_TYPE SQLCreator_RESULT_1_LV2HdoY65lk=
FACTORY_DEF * TeeFactory   FACTORY_NAME "SQLCreator_RESULT_0_sjsReQioa5E= Feature Counter -1 40"   INPUT FEATURE_TYPE SQLCreator_RESULT_0_sjsReQioa5E=   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 40")
FACTORY_DEF * BranchingFactory   FACTORY_NAME "SQLCreator_RESULT_0_sjsReQioa5E= Brancher -1 40"   INPUT FEATURE_TYPE SQLCreator_RESULT_0_sjsReQioa5E=   TARGET_FACTORY "$(WB_CURRENT_CONTEXT)_CREATOR_BRANCH_TARGET"   MAXIMUM_COUNT None   OUTPUT PASSED FEATURE_TYPE *
FACTORY_DEF * TeeFactory   FACTORY_NAME "SQLCreator_RESULT_1_LV2HdoY65lk= Feature Counter -1 41"   INPUT FEATURE_TYPE SQLCreator_RESULT_1_LV2HdoY65lk=   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 41")
FACTORY_DEF * BranchingFactory   FACTORY_NAME "SQLCreator_RESULT_1_LV2HdoY65lk= Brancher -1 41"   INPUT FEATURE_TYPE SQLCreator_RESULT_1_LV2HdoY65lk=   TARGET_FACTORY "$(WB_CURRENT_CONTEXT)_CREATOR_BRANCH_TARGET"   MAXIMUM_COUNT None   OUTPUT PASSED FEATURE_TYPE *
FACTORY_DEF * TeeFactory   FACTORY_NAME "SQLCreator_<REJECTED> Feature Counter -1 45"   INPUT FEATURE_TYPE SQLCreator_<REJECTED>   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 45")
FACTORY_DEF * BranchingFactory   FACTORY_NAME "SQLCreator_<REJECTED> Brancher -1 45"   INPUT FEATURE_TYPE SQLCreator_<REJECTED>   TARGET_FACTORY "$(WB_CURRENT_CONTEXT)_CREATOR_BRANCH_TARGET"   MAXIMUM_COUNT None   OUTPUT PASSED FEATURE_TYPE *
# -------------------------------------------------------------------------
FACTORY_DEF * TeeFactory   FACTORY_NAME "SQLCreator_2_RESULT Feature Counter -1 104"   INPUT FEATURE_TYPE SQLCreator_2_RESULT   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 104")
FACTORY_DEF * BranchingFactory   FACTORY_NAME "SQLCreator_2_RESULT Brancher -1 104"   INPUT FEATURE_TYPE SQLCreator_2_RESULT   TARGET_FACTORY "$(WB_CURRENT_CONTEXT)_CREATOR_BRANCH_TARGET"   MAXIMUM_COUNT None   OUTPUT PASSED FEATURE_TYPE *
FACTORY_DEF * TeeFactory   FACTORY_NAME "SQLCreator_2_<REJECTED> Feature Counter -1 2147614825"   INPUT FEATURE_TYPE SQLCreator_2_<REJECTED>     @LogCount("PORT -1 2147614825")
# -------------------------------------------------------------------------
MACRO SQLCreator_3_DIRECTIVES READ_TIME_WITH_TIMEZONE Yes QUERY_FEATURE_TYPES_FOR_MERGE_FILTERS Yes NAMED_CONNECTION DHS<space>Data<space>Readonly
FACTORY_DEF * CreationFactory    FACTORY_NAME SQLCreator_3_Creator    OUTPUT FEATURE_TYPE _____CREATED______
FACTORY_DEF * QueryFactory    FACTORY_NAME SQLCreator_3    INPUT FEATURE_TYPE _____CREATED______    QUERY_SQL            SELECT<space>table_schema<comma><space>table_name<comma><space>column_name<comma><space>data_type<comma><space>character_maximum_length<comma><space>ordinal_position<lf>FROM<space>information_schema.columns<space><lf>WHERE<space>table_schema<space>=<space><apos>dhs_data_tables<apos><lf>    COMBINE_ATTRIBUTES   RESULT_ONLY    COMBINE_GEOMETRY     RESULT_ONLY    READER_TYPE          POSTGRES    READER_DATASET       "DHS<space>Data<space>Readonly"    READER_PARAMS        $(SQLCreator_3_DIRECTIVES)    QUERYFCT_PROPAGATE_IDS_ON_SQL_EXECUTE YES    CONTINUE_ON_READER_ERROR YES    OUTPUT RESULT FEATURE_TYPE SQLCreator_3_RESULT        @SupplyAttributes(fme_feature_type,SQLCreator_3)    OUTPUT READER_ERROR FEATURE_TYPE SQLCreator_3_<REJECTED>
FACTORY_DEF * RecorderFactory FACTORY_NAME "SQLCreator_3_<REJECTED> Feature Recorder -1 2147614845" INPUT FEATURE_TYPE SQLCreator_3_<REJECTED> FEATURE_FILE "C:/Users/ZOOL13~1.NDP/AppData/Local/Temp/wb-cache-Load_DHS_Data_To_PG_With_Checks-F34608/Main_SQLCreator_3 -1 125 fo 1 _lt_REJECTED_gt_  0  9c9ed121cafeef8a779aa2bf47c99e349cc4b6cb.ffsupdating" MODE RECORD_PASS_THROUGH STORE_SCANNED_SCHEMA YES CREATE_SPATIAL_INDEX YES INSPECTOR YES RECORD_DIRECTLY_TO_DISK YES FSC_SCHEMA _reader_error,varchar<openparen>255<closeparen>,character_maximum_length,varchar<openparen>255<closeparen>,column_name,varchar<openparen>255<closeparen>,data_type,varchar<openparen>255<closeparen>,ordinal_position,varchar<openparen>255<closeparen>,table_name,varchar<openparen>255<closeparen>,table_schema,varchar<openparen>255<closeparen> STORE_SCANNED_METADATA PASS_THROUGH_FME_TYPE OUTPUT RECORDED FEATURE_TYPE *
FACTORY_DEF * TeeFactory   FACTORY_NAME "SQLCreator_3_RESULT Feature Counter -1 131"   INPUT FEATURE_TYPE SQLCreator_3_RESULT   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 131")
FACTORY_DEF * BranchingFactory   FACTORY_NAME "SQLCreator_3_RESULT Brancher -1 131"   INPUT FEATURE_TYPE SQLCreator_3_RESULT   TARGET_FACTORY "$(WB_CURRENT_CONTEXT)_CREATOR_BRANCH_TARGET"   MAXIMUM_COUNT None   OUTPUT PASSED FEATURE_TYPE *
FACTORY_DEF * TeeFactory   FACTORY_NAME "SQLCreator_3_<REJECTED> Feature Counter -1 2147614845"   INPUT FEATURE_TYPE SQLCreator_3_<REJECTED>     @LogCount("PORT -1 2147614845")
# -------------------------------------------------------------------------
FACTORY_DEF * TeeFactory   FACTORY_NAME "$(WB_CURRENT_CONTEXT)_CREATOR_BRANCH_TARGET"   INPUT FEATURE_TYPE *  OUTPUT FEATURE_TYPE *
# -------------------------------------------------------------------------
FACTORY_DEF * SortFactory    FACTORY_NAME Sorter    INPUT  FEATURE_TYPE SQLCreator_3_RESULT    SORT_BY table_name ALPHA ASCENDING ordinal_position NUMERIC ASCENDING    OUTPUT SORTED FEATURE_TYPE Sorter_SORTED
FACTORY_DEF * TeeFactory   FACTORY_NAME "Sorter_SORTED Feature Counter -1 127"   INPUT FEATURE_TYPE Sorter_SORTED   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 127")
# -------------------------------------------------------------------------
FACTORY_DEF * TestFactory    FACTORY_NAME Tester_4    INPUT  FEATURE_TYPE Sorter_SORTED    TEST @EvaluateExpression(FDIV,STRING_ENCODED,<at>Value<openparen>data_type<closeparen>,Tester_4) = character<space>varying ENCODED    BOOLEAN_OPERATOR OR    OUTPUT PASSED FEATURE_TYPE Tester_4_PASSED    OUTPUT FAILED FEATURE_TYPE Tester_4_FAILED
FACTORY_DEF * TeeFactory   FACTORY_NAME "Tester_4_PASSED Feature Counter -1 132"   INPUT FEATURE_TYPE Tester_4_PASSED   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 132")
FACTORY_DEF * TeeFactory   FACTORY_NAME "Tester_4_FAILED Feature Counter -1 137"   INPUT FEATURE_TYPE Tester_4_FAILED   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 137")
# -------------------------------------------------------------------------
FACTORY_DEF {*} AttrSetFactory    COMMAND_PARM_EVALUATION SINGLE_PASS    FACTORY_NAME AttributeManager_2    INPUT  FEATURE_TYPE Tester_4_FAILED    MULTI_FEATURE_MODE NO     NULL_ATTR_MODE NO_OP     ATTRSET_CREATE_DIRECTIVES _PROPAGATE_MISSING_FDIV    ACTION_COLUMN 3    DEF_VAL_COLUMN 2    ATTR_ACTION { "" "fme_data_type" "fme_json" "SET_TO" }      ATTR_ACTION { "character_maximum_length" "character_maximum_length" "" "REMOVE" }      ATTR_ACTION { "column_name" "name" "" "RENAME_SET_VALUE" }      ATTR_ACTION { "data_type" "data_type" "" "REMOVE" }      ATTR_ACTION { "table_name" "RecordName" "" "RENAME_SET_VALUE" }      ATTR_ACTION { "" "_qual_tbl_name" "<at>Value<openparen>table_schema<closeparen>.<at>Value<openparen>RecordName<closeparen>" "SET_TO" }      ATTR_ACTION { "table_schema" "table_schema" "" "REMOVE" }      ATTR_ACTION { "ordinal_position" "ordinal_position" "" "REMOVE" }    OUTPUT OUTPUT FEATURE_TYPE AttributeManager_2_OUTPUT
FACTORY_DEF * TeeFactory   FACTORY_NAME "AttributeManager_2_OUTPUT Feature Counter -1 138"   INPUT FEATURE_TYPE AttributeManager_2_OUTPUT   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 138")
# -------------------------------------------------------------------------
FACTORY_DEF {*} AttrSetFactory    COMMAND_PARM_EVALUATION SINGLE_PASS    FACTORY_NAME AttributeManager    INPUT  FEATURE_TYPE Tester_4_PASSED    MULTI_FEATURE_MODE NO     NULL_ATTR_MODE NO_OP     ATTRSET_CREATE_DIRECTIVES _PROPAGATE_MISSING_FDIV    ACTION_COLUMN 3    DEF_VAL_COLUMN 2    ATTR_ACTION { "" "fme_data_type" "fme_varchar<openparen><at>Value<openparen>character_maximum_length<closeparen><closeparen>" "SET_TO" }      ATTR_ACTION { "character_maximum_length" "character_maximum_length" "" "REMOVE" }      ATTR_ACTION { "column_name" "name" "" "RENAME_SET_VALUE" }      ATTR_ACTION { "data_type" "data_type" "" "REMOVE" }      ATTR_ACTION { "table_name" "RecordName" "" "RENAME_SET_VALUE" }      ATTR_ACTION { "" "_qual_tbl_name" "<at>Value<openparen>table_schema<closeparen>.<at>Value<openparen>RecordName<closeparen>" "SET_TO" }      ATTR_ACTION { "table_schema" "table_schema" "" "REMOVE" }      ATTR_ACTION { "ordinal_position" "ordinal_position" "" "REMOVE" }    OUTPUT OUTPUT FEATURE_TYPE AttributeManager_OUTPUT
FACTORY_DEF * TeeFactory   FACTORY_NAME "AttributeManager_OUTPUT Feature Counter -1 133"   INPUT FEATURE_TYPE AttributeManager_OUTPUT   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 133")
# -------------------------------------------------------------------------
FACTORY_DEF * TeeFactory    FACTORY_NAME ListBuilder_fme_type_remover    INPUT  FEATURE_TYPE AttributeManager_OUTPUT    INPUT  FEATURE_TYPE AttributeManager_2_OUTPUT    OUTPUT FEATURE_TYPE ListBuilder_no_fme_type       @RemoveAttributes(fme_type,fme_geometry)
FACTORY_DEF {*} ListFactory    FACTORY_NAME ListBuilder    INPUT FEATURE_TYPE ListBuilder_no_fme_type    LIST_NAME "attribute{}"    LIST_ATTRS_TO_INCLUDE { fme_data_type name }    LIST_ATTRS_TO_INCLUDE_MODE SELECTED    GROUP_BY { RecordName _qual_tbl_name }    ORDERED_BY_GROUP No    OUTPUT LIST FEATURE_TYPE ListBuilder_OUTPUT
FACTORY_DEF * TeeFactory   FACTORY_NAME "ListBuilder OUTPUT Splitter"   INPUT FEATURE_TYPE ListBuilder_OUTPUT   OUTPUT FEATURE_TYPE ListBuilder_OUTPUT_0_JDZQCVAu4hQ=   OUTPUT FEATURE_TYPE ListBuilder_OUTPUT_1_3ZjSSa3+ink=
FACTORY_DEF * TeeFactory   FACTORY_NAME "ListBuilder_OUTPUT_0_JDZQCVAu4hQ= Feature Counter -1 135"   INPUT FEATURE_TYPE ListBuilder_OUTPUT_0_JDZQCVAu4hQ=   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 135")
FACTORY_DEF * TeeFactory   FACTORY_NAME "ListBuilder_OUTPUT_1_3ZjSSa3+ink= Feature Counter -1 176"   INPUT FEATURE_TYPE ListBuilder_OUTPUT_1_3ZjSSa3+ink=   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 176")
# -------------------------------------------------------------------------
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [    set safeName "[regsub -all {[^a-zA-Z0-9]} {ListBuilder_Output} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";    puts "MACRO SAFE_FFS_NAME $safeName"; ]
FACTORY_DEF {*} InspectorFactory    FACTORY_NAME ListBuilder_Output_Prepper    COMMAND_PARM_EVALUATION SINGLE_PASS    INPUT  FEATURE_TYPE ListBuilder_OUTPUT_1_3ZjSSa3+ink=    GROUP_ATTRIBUTE __inspector_feature_type_attr__    GROUP_BY {  }    GROUP_ATTRIBUTE_PREFIX { ListBuilder_Output }    RASTER_REDUCTION NoReduction    POINT_CLOUD_REDUCTION NO_THINNING    OUTPUT RESULT FEATURE_TYPE __viewme__
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.
FACTORY_DEF * RecorderFactory    FACTORY_NAME ListBuilder_Output_Recorder    COMMAND_PARM_EVALUATION SINGLE_PASS    INPUT FEATURE_TYPE __viewme__       _wb_termination_feature Yes       @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__       @FeatureType(@Value(__inspector_feature_type_attr__))       @RemoveAttributes(__inspector_feature_type_attr__)    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    STORE_SCANNED_SCHEMA YES    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA RecordName,varchar<openparen>255<closeparen>,_qual_tbl_name,varchar<openparen>255<closeparen>    MODE RECORD    STORE_SCANNED_METADATA    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000
# -------------------------------------------------------------------------
# most of this is close to the code from listindexer but not exact beucase
# we have a type LIST_ATTR rather than type LIST_NAME so need
# to figure out the list name
Tcl2 proc ListSearcher_12c30b47_594b_4b80_8f46_1b6aee2a89050_indexer {index prefix} {    set fullListAttrName [FME_DecodeText attribute<opencurly><closecurly>.fme_data_type];    set lastBrace [string last  \"{}\" $fullListAttrName];    set listAttr [string range $fullListAttrName 0 [expr $lastBrace+1]];    regsub \"{}\" $listAttr \"{$index}\" listWithIndex;    regsub \"{}\" $listAttr {} listBase;    set complexListExp "$listWithIndex\.";    set prefixLength [expr [string length $complexListExp]-1];    set prefix [FME_DecodeText $prefix];    foreach attr [FME_AttributeNames] {      set newAttr {};      if {$attr == $listWithIndex} {        set newAttr $listBase;      } elseif {[string first $complexListExp $attr] == 0} {        set newAttr [string replace $attr 0 $prefixLength];      };      if {$newAttr != {}} {          if {$prefix != {} } {            set newAttr $prefix$newAttr;          };          if {[string first {fme_} $newAttr] != 0} {              set first [string first {fme_} $newAttr];              lappend attrsToCopy $newAttr $attr;          };      };    };    if {[info exists attrsToCopy] && [llength $attrsToCopy] > 0} {      eval FME_Execute CopyAttributes $attrsToCopy;    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME ListSearcher    INPUT  FEATURE_TYPE ListBuilder_OUTPUT_0_JDZQCVAu4hQ=    OUTPUT FEATURE_TYPE ListSearcher__IndexedFeatures___         "ListSearcher_12c30b47_594b_4b80_8f46_1b6aee2a89050" @SearchList(fme_encoded,"attribute<opencurly><closecurly>.fme_data_type","fme_json",FIRST_MATCHED_ENCODED)
FACTORY_DEF * TestFactory    FACTORY_NAME ListSearcher__Tester    INPUT FEATURE_TYPE ListSearcher__IndexedFeatures___    TEST @Value(ListSearcher_12c30b47_594b_4b80_8f46_1b6aee2a89050) == "-1"    OUTPUT PASSED FEATURE_TYPE  ListSearcher_NOT_FOUND @RemoveAttributes(ListSearcher_12c30b47_594b_4b80_8f46_1b6aee2a89050)    OUTPUT FAILED FEATURE_TYPE  ListSearcher__IndexFound__
FACTORY_DEF * TestFactory    FACTORY_NAME ListSearcher__Tester2    INPUT FEATURE_TYPE ListSearcher__IndexFound__    TEST NO == "NO"    OUTPUT PASSED FEATURE_TYPE  ListSearcher_FOUND @CopyAttributes(_list_index, ListSearcher_12c30b47_594b_4b80_8f46_1b6aee2a89050) @RemoveAttributes(ListSearcher_12c30b47_594b_4b80_8f46_1b6aee2a89050)    OUTPUT FAILED FEATURE_TYPE  ListSearcher_FOUND  @Tcl2("ListSearcher_12c30b47_594b_4b80_8f46_1b6aee2a89050_indexer {@Value(ListSearcher_12c30b47_594b_4b80_8f46_1b6aee2a89050)} {<Unused>}") @CopyAttributes(_list_index, ListSearcher_12c30b47_594b_4b80_8f46_1b6aee2a89050) @RemoveAttributes(ListSearcher_12c30b47_594b_4b80_8f46_1b6aee2a89050)
FACTORY_DEF * TeeFactory   FACTORY_NAME "ListSearcher_NOT_FOUND Feature Counter -1 139"   INPUT FEATURE_TYPE ListSearcher_NOT_FOUND   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 139")
FACTORY_DEF * TeeFactory   FACTORY_NAME "ListSearcher_FOUND Feature Counter -1 141"   INPUT FEATURE_TYPE ListSearcher_FOUND   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 141")
# -------------------------------------------------------------------------
FACTORY_DEF {*} AttrSetFactory    COMMAND_PARM_EVALUATION SINGLE_PASS    FACTORY_NAME AttributeManager_3    INPUT  FEATURE_TYPE ListSearcher_FOUND    MULTI_FEATURE_MODE NO     NULL_ATTR_MODE NO_OP     ATTRSET_CREATE_DIRECTIVES _PROPAGATE_MISSING_FDIV    ACTION_COLUMN 3    DEF_VAL_COLUMN 2    ATTR_ACTION { "" "_is_json" "1" "SET_TO" }    OUTPUT OUTPUT FEATURE_TYPE AttributeManager_3_OUTPUT
FACTORY_DEF * TeeFactory   FACTORY_NAME "AttributeManager_3_OUTPUT Feature Counter -1 144"   INPUT FEATURE_TYPE AttributeManager_3_OUTPUT   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 144")
# -------------------------------------------------------------------------
FACTORY_DEF {*} AttrSetFactory    COMMAND_PARM_EVALUATION SINGLE_PASS    FACTORY_NAME AttributeManager_4    INPUT  FEATURE_TYPE ListSearcher_NOT_FOUND    MULTI_FEATURE_MODE NO     NULL_ATTR_MODE NO_OP     ATTRSET_CREATE_DIRECTIVES _PROPAGATE_MISSING_FDIV    ACTION_COLUMN 3    DEF_VAL_COLUMN 2    ATTR_ACTION { "" "_is_json" "0" "SET_TO" }    OUTPUT OUTPUT FEATURE_TYPE AttributeManager_4_OUTPUT
FACTORY_DEF * TeeFactory   FACTORY_NAME "AttributeManager_4_OUTPUT Feature Counter -1 143"   INPUT FEATURE_TYPE AttributeManager_4_OUTPUT   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 143")
# -------------------------------------------------------------------------
# The default behaviour is to abort on any feature entering the transformer.
# If Workbench has set the _WB_BYPASS_TERMINATION macro to a value of "Yes",
# then the features will instead be passed through with a feature type of
# __WB_BYPASS_TERMINATOR__, which Workbench will send to a visualizer or
# somesuch.
DEFAULT_MACRO _WB_BYPASS_TERMINATION No
FACTORY_DEF * TestFactory    FACTORY_NAME Terminator    INPUT  FEATURE_TYPE SQLCreator_<REJECTED>    TEST "$(_WB_BYPASS_TERMINATION)" == Yes    OUTPUT PASSED FEATURE_TYPE __WB_BYPASS_TERMINATOR__       @SupplyAttributes(_wb_termination_feature_type,@FeatureType())       @SupplyAttributes(ENCODED,_wb_termination_message,"Translation Terminated")       @SupplyAttributes(_wb_termination_xformer,"Terminator")       @SupplyAttributes(_wb_termination_feature,Yes)    OUTPUT FAILED FEATURE_TYPE * @Abort(ENCODED,"Translation Terminated")
# -------------------------------------------------------------------------
MACRO SQLExecutor_2_DIRECTIVES NAMED_CONNECTION DHS<space>Data<space>Readonly QUERY_FEATURE_TYPES_FOR_MERGE_FILTERS Yes
FACTORY_DEF * QueryFactory    FACTORY_NAME SQLExecutor_2    INPUT  FEATURE_TYPE SQLCreator_RESULT_0_sjsReQioa5E=    QUERY_SQL            "@EvaluateExpression(FDIV,STRING_ENCODED,SELECT<space>surveyid<comma><space>count<openparen>*<closeparen><space>nrows_db<space>FROM<space>dhs_data_tables.<quote><at>Value<openparen>table_name<closeparen><quote><space>GROUP<space>BY<space>surveyid,SQLExecutor_2)"    READER_TYPE          POSTGRES    READER_DATASET       "DHS<space>Data<space>Readonly"    COMBINE_ATTRIBUTES   PREFER_RESULT    COMBINE_GEOMETRY     QUERY_ONLY    CONTINUE_ON_READER_ERROR YES    QUERYFCT_PROPAGATE_IDS_ON_SQL_EXECUTE YES    READER_PARAMS        $(SQLExecutor_2_DIRECTIVES)    OUTPUT RESULT FEATURE_TYPE SQLExecutor_2_RESULT    OUTPUT QUERY FEATURE_TYPE SQLExecutor_2_INITIATOR    OUTPUT READER_ERROR FEATURE_TYPE SQLExecutor_2_<REJECTED>
FACTORY_DEF * TeeFactory   FACTORY_NAME "SQLExecutor_2 INITIATOR Transformer Output Nuker"   INPUT FEATURE_TYPE SQLExecutor_2_INITIATOR
FACTORY_DEF * RecorderFactory FACTORY_NAME "SQLExecutor_2_<REJECTED> Feature Recorder -1 2147745804" INPUT FEATURE_TYPE SQLExecutor_2_<REJECTED> FEATURE_FILE "C:/Users/ZOOL13~1.NDP/AppData/Local/Temp/wb-cache-Load_DHS_Data_To_PG_With_Checks-F34608/Main_SQLExecutor_2 -1 12 fo 2 _lt_REJECTED_gt_  0  3b415f57be70d339d18284f2cfc9a8ac1a3c36a1.ffsupdating" MODE RECORD_PASS_THROUGH STORE_SCANNED_SCHEMA YES CREATE_SPATIAL_INDEX YES INSPECTOR YES RECORD_DIRECTLY_TO_DISK YES FSC_SCHEMA table_name,varchar<openparen>255<closeparen>,_reader_error,varchar<openparen>255<closeparen>,surveyid,varchar<openparen>255<closeparen>,nrows_db,varchar<openparen>255<closeparen> STORE_SCANNED_METADATA PASS_THROUGH_FME_TYPE OUTPUT RECORDED FEATURE_TYPE *
FACTORY_DEF * TeeFactory   FACTORY_NAME "SQLExecutor_2_RESULT Feature Counter -1 51"   INPUT FEATURE_TYPE SQLExecutor_2_RESULT   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 51")
FACTORY_DEF * TeeFactory   FACTORY_NAME "SQLExecutor_2_<REJECTED> Feature Counter -1 2147745804"   INPUT FEATURE_TYPE SQLExecutor_2_<REJECTED>     @LogCount("PORT -1 2147745804")
# -------------------------------------------------------------------------
FACTORY_DEF * AttrSetFactory FACTORY_NAME AttributeCreator ATTRSET_CREATE_DIRECTIVES _PROPAGATE_MISSING_FDIV INPUT  FEATURE_TYPE AllSchemas_20170410_FFS_1 ATTR qualtablename dhs_data_tables.<at>Value<openparen>RecordName<closeparen>    OUTPUT OUTPUT FEATURE_TYPE AttributeCreator_OUTPUT 
FACTORY_DEF * TeeFactory   FACTORY_NAME "AttributeCreator_OUTPUT Feature Counter -1 46"   INPUT FEATURE_TYPE AttributeCreator_OUTPUT   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 46")
# -------------------------------------------------------------------------
FACTORY_DEF * TeeFactory    FACTORY_NAME ListElementCounter    INPUT  FEATURE_TYPE AttributeCreator_OUTPUT    OUTPUT FEATURE_TYPE ListElementCounter_OUTPUT         "_column_count" @NumElements("attribute<opencurly><closecurly>",ENCODED)
FACTORY_DEF * TeeFactory   FACTORY_NAME "ListElementCounter OUTPUT Splitter"   INPUT FEATURE_TYPE ListElementCounter_OUTPUT   OUTPUT FEATURE_TYPE ListElementCounter_OUTPUT_0_FzUB1QcTW68=   OUTPUT FEATURE_TYPE ListElementCounter_OUTPUT_1_byrW5HO4yhE=
FACTORY_DEF * TeeFactory   FACTORY_NAME "ListElementCounter_OUTPUT_0_FzUB1QcTW68= Feature Counter -1 47"   INPUT FEATURE_TYPE ListElementCounter_OUTPUT_0_FzUB1QcTW68=   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 47")
FACTORY_DEF * TeeFactory   FACTORY_NAME "ListElementCounter_OUTPUT_1_byrW5HO4yhE= Feature Counter -1 106"   INPUT FEATURE_TYPE ListElementCounter_OUTPUT_1_byrW5HO4yhE=   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 106")
# -------------------------------------------------------------------------
FACTORY_DEF * TeeFactory   FACTORY_NAME "FeatureMerger_5 (Disabled) Nuker"   INPUT FEATURE_TYPE SQLCreator_2_RESULT   INPUT FEATURE_TYPE ListElementCounter_OUTPUT_1_byrW5HO4yhE=
FACTORY_DEF * TeeFactory   FACTORY_NAME "FeatureMerger_5_MERGED Feature Counter -1 108"   INPUT FEATURE_TYPE FeatureMerger_5_MERGED   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 108")
FACTORY_DEF * TeeFactory   FACTORY_NAME "FeatureMerger_5_UNMERGED_REQUESTOR Feature Counter -1 111"   INPUT FEATURE_TYPE FeatureMerger_5_UNMERGED_REQUESTOR   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 111")
FACTORY_DEF * TeeFactory   FACTORY_NAME "FeatureMerger_5_UNUSED_SUPPLIER Feature Counter -1 113"   INPUT FEATURE_TYPE FeatureMerger_5_UNUSED_SUPPLIER   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 113")
FACTORY_DEF * TeeFactory   FACTORY_NAME "FeatureMerger_5_<REJECTED> Feature Counter -1 2147876967"   INPUT FEATURE_TYPE FeatureMerger_5_<REJECTED>     @LogCount("PORT -1 2147876967")
# -------------------------------------------------------------------------
FACTORY_DEF * TeeFactory   FACTORY_NAME "FeatureMerger_5_UnusedSupplier (Disabled) Nuker"   INPUT FEATURE_TYPE FeatureMerger_5_UNUSED_SUPPLIER
# -------------------------------------------------------------------------
FACTORY_DEF * TeeFactory   FACTORY_NAME "FeatureMerger_5_UnmergedRequestor (Disabled) Nuker"   INPUT FEATURE_TYPE FeatureMerger_5_UNMERGED_REQUESTOR
# -------------------------------------------------------------------------
FACTORY_DEF * TeeFactory   FACTORY_NAME "FeatureMerger_5_Merged (Disabled) Nuker"   INPUT FEATURE_TYPE FeatureMerger_5_MERGED
# -------------------------------------------------------------------------
FACTORY_DEF * TestFactory    FACTORY_NAME Tester    INPUT  FEATURE_TYPE ListElementCounter_OUTPUT_0_FzUB1QcTW68=    TEST @EvaluateExpression(FDIV,STRING_ENCODED,<at>Value<openparen>_column_count<closeparen>,Tester) <= 1600 ENCODED    BOOLEAN_OPERATOR AND    OUTPUT PASSED FEATURE_TYPE Tester_PASSED    OUTPUT FAILED FEATURE_TYPE Tester_FAILED
FACTORY_DEF * TeeFactory   FACTORY_NAME "Tester_PASSED Feature Counter -1 49"   INPUT FEATURE_TYPE Tester_PASSED   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 49")
FACTORY_DEF * TeeFactory   FACTORY_NAME "Tester_FAILED Feature Counter -1 68"   INPUT FEATURE_TYPE Tester_FAILED   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 68")
# -------------------------------------------------------------------------
FACTORY_DEF * TeeFactory   FACTORY_NAME "JSON_Tables (Disabled) Nuker"   INPUT FEATURE_TYPE Tester_FAILED
# -------------------------------------------------------------------------
# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.
READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Normal_Tables} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Normal_Tables_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Normal_Tables_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing
FACTORY_DEF * TestFactory    FACTORY_NAME Normal_Tables_FeatureDirector    INPUT  FEATURE_TYPE Tester_PASSED    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Normal_Tables___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Normal_Tables___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Normal_Tables___FeatureDirector1    INPUT FEATURE_TYPE Normal_Tables___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Normal_Tables___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Normal_Tables___PointCloudFeatures___
# Vector features simply may get their colors overridden
FACTORY_DEF * TeeFactory    FACTORY_NAME Normal_Tables_VectorSetterUpper    INPUT FEATURE_TYPE Normal_Tables___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned
# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.
Tcl2 proc Normal_Tables_9253c717_bce8_49b9_993d_1cf3826f35720_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Normal_Tables___PointCloudThinner    INPUT FEATURE_TYPE Normal_Tables___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Normal_Tables_9253c717_bce8_49b9_993d_1cf3826f35720_thinPointCloud")
Tcl2 proc Normal_Tables_9253c717_bce8_49b9_993d_1cf3826f35720_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Normal_Tables_RasterSetterUpper    INPUT FEATURE_TYPE Normal_Tables___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Normal_Tables_9253c717_bce8_49b9_993d_1cf3826f35720_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Normal_Tables_9253c717_bce8_49b9_993d_1cf3826f35720_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.
DEFAULT_MACRO Normal_Tables_9253c717_bce8_49b9_993d_1cf3826f35720_VIS_FEAT_TYPE Normal_Tables$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.
FACTORY_DEF * RecorderFactory    FACTORY_NAME Normal_Tables_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Normal_Tables_9253c717_bce8_49b9_993d_1cf3826f35720_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA RecordName,varchar<openparen>255<closeparen>,qualtablename,varchar<openparen>255<closeparen>,_column_count,varchar<openparen>255<closeparen>    MODE RECORD    STORE_SCANNED_METADATA    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000
# -------------------------------------------------------------------------
MACRO casemac
INCLUDE [ if { {no} == {no} } { puts {MACRO casemac -nocase}} ]
Tcl2 proc StringSearcher_3_f570d278_99fa_4b1c_bed9_7d232f5480500_doGrep { stringToSearch regExp matchedChars matches matchedParts } {   set subMatches 1;   set matches [FME_DecodeText $matches];   set matchedParts [FME_DecodeText $matchedParts];   set results [FME_GetRegex $(casemac) [FME_DecodeText $regExp] [FME_DecodeText $stringToSearch]];   if {[llength [lindex $results 0]] > 0} {      set attrName [FME_DecodeText $matchedChars];      FME_SetAttribute $attrName [lindex [lindex [lindex $results 0] 0] 0];      set index 0;      set parts [lindex $results 1];      foreach part $parts {         if {[llength $matchedParts] > 0} {             set attrName "$matchedParts{$index}.part";             FME_SetAttribute $attrName [lindex $part 0];             set attrName "$matchedParts{$index}.startIndex";             FME_SetAttribute $attrName [lindex $part 1];         };         incr index;      };      set index 0;      set regexMatches [lindex $results 0];      foreach part $regexMatches {         if {[llength $matches] > 0} {             set attrName "$matches{$index}.match";             FME_SetAttribute $attrName [lindex $part 0];             set attrName "$matches{$index}.startIndex";             FME_SetAttribute $attrName [lindex $part 1];         };         set isFirstMatch 0;         incr index;      };      return $index;   };   return -1; }
FACTORY_DEF * TestFactory    FACTORY_NAME StringSearcher_3    INPUT  FEATURE_TYPE PATH_PATH_1    TEST @Tcl2("StringSearcher_3_f570d278_99fa_4b1c_bed9_7d232f5480500_doGrep {@EvaluateExpression(FDIV,STRING_ENCODED,<at>Value<openparen>path_filename<closeparen>,StringSearcher_3)} {^<backslash>d+} {SurveyID_File} {} {}") > 0    OUTPUT PASSED FEATURE_TYPE StringSearcher_3_MATCHED
FACTORY_DEF * TeeFactory   FACTORY_NAME "StringSearcher_3_MATCHED Feature Counter -1 63"   INPUT FEATURE_TYPE StringSearcher_3_MATCHED   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 63")
# -------------------------------------------------------------------------
MACRO casemac
INCLUDE [ if { {no} == {no} } { puts {MACRO casemac -nocase}} ]
Tcl2 proc StringSearcher_2_c3ac08c8_7b65_4dee_90bb_3621208da7a80_doGrep { stringToSearch regExp matchedChars matches matchedParts } {   set subMatches 1;   set matches [FME_DecodeText $matches];   set matchedParts [FME_DecodeText $matchedParts];   set results [FME_GetRegex $(casemac) [FME_DecodeText $regExp] [FME_DecodeText $stringToSearch]];   if {[llength [lindex $results 0]] > 0} {      set attrName [FME_DecodeText $matchedChars];      FME_SetAttribute $attrName [lindex [lindex [lindex $results 0] 0] 0];      set index 0;      set parts [lindex $results 1];      foreach part $parts {         if {[llength $matchedParts] > 0} {             set attrName "$matchedParts{$index}.part";             FME_SetAttribute $attrName [lindex $part 0];             set attrName "$matchedParts{$index}.startIndex";             FME_SetAttribute $attrName [lindex $part 1];         };         incr index;      };      set index 0;      set regexMatches [lindex $results 0];      foreach part $regexMatches {         if {[llength $matches] > 0} {             set attrName "$matches{$index}.match";             FME_SetAttribute $attrName [lindex $part 0];             set attrName "$matches{$index}.startIndex";             FME_SetAttribute $attrName [lindex $part 1];         };         set isFirstMatch 0;         incr index;      };      return $index;   };   return -1; }
FACTORY_DEF * TestFactory    FACTORY_NAME StringSearcher_2    INPUT  FEATURE_TYPE StringSearcher_3_MATCHED    TEST @Tcl2("StringSearcher_2_c3ac08c8_7b65_4dee_90bb_3621208da7a80_doGrep {@EvaluateExpression(FDIV,STRING_ENCODED,<at>Value<openparen>path_filename<closeparen>,StringSearcher_2)} {M?REC<openbracket>0-9A-Z<closebracket><opencurly>2<comma>4<closecurly>} {RecordName_File} {} {}") > 0    OUTPUT PASSED FEATURE_TYPE StringSearcher_2_MATCHED    OUTPUT FAILED FEATURE_TYPE StringSearcher_2_NOT_MATCHED
FACTORY_DEF * TeeFactory   FACTORY_NAME "StringSearcher_2_MATCHED Feature Counter -1 53"   INPUT FEATURE_TYPE StringSearcher_2_MATCHED   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 53")
FACTORY_DEF * TeeFactory   FACTORY_NAME "StringSearcher_2_NOT_MATCHED Feature Counter -1 73"   INPUT FEATURE_TYPE StringSearcher_2_NOT_MATCHED   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 73")
# -------------------------------------------------------------------------
INCLUDE [    if { {MATCH} == {MATCH} } {       puts {MACRO Matcher_ATTRMATCH MATCH_ATTRIBUTES RecordName_File SurveyID_File};    }    elseif { {MATCH} == {EXCEPT} } {       puts {MACRO Matcher_ATTRMATCH MATCH_ALL_ATTRS_EXCEPT RecordName_File SurveyID_File};    }    else {       puts {MACRO Matcher_ATTRMATCH MATCH_ALL_ATTRIBUTES};    }
FACTORY_DEF {*} MatchingFactory    FACTORY_NAME Matcher    INPUT  FEATURE_TYPE StringSearcher_2_MATCHED    MATCH_GEOMETRY 2D    $(Matcher_ATTRMATCH)    BLANK_AND_MISSING_DIFFER No    LENIENT_GEOMETRY_MATCH No    ADD_TO_MATCHED _match_id @Count(Matcher)    OUTPUT MATCHED FEATURE_TYPE Matcher_MATCHED    OUTPUT NOT_MATCHED FEATURE_TYPE Matcher_NOT_MATCHED
FACTORY_DEF * TeeFactory   FACTORY_NAME "Matcher NOT_MATCHED Splitter"   INPUT FEATURE_TYPE Matcher_NOT_MATCHED   OUTPUT FEATURE_TYPE Matcher_NOT_MATCHED_0_CJhMt99ptPY=   OUTPUT FEATURE_TYPE Matcher_NOT_MATCHED_1_t0ID0J5ocq4=
FACTORY_DEF * TeeFactory   FACTORY_NAME "Matcher_MATCHED Feature Counter -1 56"   INPUT FEATURE_TYPE Matcher_MATCHED   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 56")
FACTORY_DEF * TeeFactory   FACTORY_NAME "Matcher_NOT_MATCHED_0_CJhMt99ptPY= Feature Counter -1 81"   INPUT FEATURE_TYPE Matcher_NOT_MATCHED_0_CJhMt99ptPY=   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 81")
FACTORY_DEF * TeeFactory   FACTORY_NAME "Matcher_NOT_MATCHED_1_t0ID0J5ocq4= Feature Counter -1 173"   INPUT FEATURE_TYPE Matcher_NOT_MATCHED_1_t0ID0J5ocq4=   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 173")
# -------------------------------------------------------------------------
FACTORY_DEF * TestFactory    FACTORY_NAME Tester_6    INPUT  FEATURE_TYPE Matcher_NOT_MATCHED_1_t0ID0J5ocq4=    TEST @EvaluateExpression(FDIV,STRING_ENCODED,<at>Value<openparen>SurveyID_File<closeparen>,Tester_6) = 304 ENCODED    BOOLEAN_OPERATOR OR    OUTPUT PASSED FEATURE_TYPE Tester_6_PASSED
FACTORY_DEF * TeeFactory   FACTORY_NAME "Tester_6_PASSED Feature Counter -1 174"   INPUT FEATURE_TYPE Tester_6_PASSED   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 174")
# -------------------------------------------------------------------------
INCLUDE [if { {ATTRIBUTES} == {ATTRIBUTES} } {                puts "MACRO FeatureMerger_REFERENCE_INFO ATTRIBUTES";             }          elseif { {ATTRIBUTES} == {GEOM_BUILD} && {<Unused>} == {POLYGONS}} {                puts "MACRO FeatureMerger_REFERENCE_INFO GEOM_BUILD_POLYS";             }          elseif { {ATTRIBUTES} == {GEOM_BUILD} && {<Unused>} == {AGGREGATES}} {                puts "MACRO FeatureMerger_REFERENCE_INFO GEOM_BUILD_AGGREGATES";             }          elseif { {ATTRIBUTES} == {GEOM_BUILD} && {<Unused>} == {LINESFROMPOINTS}} {                puts "MACRO FeatureMerger_REFERENCE_INFO GEOM_BUILD_LINES_FROM_POINTS";             }          elseif { {ATTRIBUTES} == {GEOM_AND_ATTRS} && {<Unused>} == {POLYGONS}} {                puts "MACRO FeatureMerger_REFERENCE_INFO GEOM_AND_ATTR_BUILD_POLYS";             }          elseif { {ATTRIBUTES} == {GEOM_AND_ATTRS} && {<Unused>} == {AGGREGATES}} {                puts "MACRO FeatureMerger_REFERENCE_INFO GEOM_AND_ATTR_BUILD_AGGREGATES";             }          elseif { {ATTRIBUTES} == {GEOM_AND_ATTRS} && {<Unused>} == {LINESFROMPOINTS}} {                puts "MACRO FeatureMerger_REFERENCE_INFO GEOM_AND_ATTR_BUILD_LINES_FROM_POINTS";             }          elseif { {ATTRIBUTES} == {GEOM_BUILD} } {                puts "MACRO FeatureMerger_REFERENCE_INFO GEOM_BUILD_AGGREGATES";             }          elseif { {ATTRIBUTES} == {GEOM_AND_ATTRS} } {                puts "MACRO FeatureMerger_REFERENCE_INFO GEOM_AND_ATTR_BUILD_AGGREGATES";             }          else {}; ]
FACTORY_DEF {*} ReferenceFactory    FACTORY_NAME FeatureMerger    INPUT REFERENCER FEATURE_TYPE Tester_6_PASSED    INPUT REFERENCEE FEATURE_TYPE SQLCreator_RESULT_1_LV2HdoY65lk=    REFERENCE_INFO $(FeatureMerger_REFERENCE_INFO)    REFERENCE_TABLE @EvaluateExpression(FDIV,STRING_ENCODED,<at>Value<openparen>RecordName_File<closeparen>,FeatureMerger) @EvaluateExpression(FDIV,STRING_ENCODED,<at>Value<openparen>table_name<closeparen>,FeatureMerger) AUTO    ATTR_ACCUM_MODE "HANDLE_CONFLICT"    ATTR_CONFLICT_RES "REQUESTOR_IF_CONFLICT"    IGNORE_NULLS "No"    HANDLE_NULL_MISSING_KEYS_LIKE_FME2013 No    MERGE_ATTRIBUTES Yes    MANAGE_FME_TYPE Yes    MODE COMPLETE    PROCESS_DUPLICATE_REFERENCEES No    REFERENCEES_FIRST Yes    OUTPUT COMPLETE FEATURE_TYPE FeatureMerger_MERGED    OUTPUT INCOMPLETE FEATURE_TYPE FeatureMerger_NOT_MERGED
FACTORY_DEF * TeeFactory   FACTORY_NAME "FeatureMerger NOT_MERGED Splitter"   INPUT FEATURE_TYPE FeatureMerger_NOT_MERGED   OUTPUT FEATURE_TYPE FeatureMerger_NOT_MERGED_0_mc6xVklKjb8=   OUTPUT FEATURE_TYPE FeatureMerger_NOT_MERGED_1_LpSJBSvR7Fc=
FACTORY_DEF * TeeFactory   FACTORY_NAME "FeatureMerger_MERGED Feature Counter -1 50"   INPUT FEATURE_TYPE FeatureMerger_MERGED   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 50")
FACTORY_DEF * TeeFactory   FACTORY_NAME "FeatureMerger_NOT_MERGED_0_mc6xVklKjb8= Feature Counter -1 121"   INPUT FEATURE_TYPE FeatureMerger_NOT_MERGED_0_mc6xVklKjb8=   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 121")
FACTORY_DEF * TeeFactory   FACTORY_NAME "FeatureMerger_NOT_MERGED_1_LpSJBSvR7Fc= Feature Counter -1 70"   INPUT FEATURE_TYPE FeatureMerger_NOT_MERGED_1_LpSJBSvR7Fc=   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 70")
# -------------------------------------------------------------------------
# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.
READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Table_Not_Yet_Begun} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Table_Not_Yet_Begun_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Table_Not_Yet_Begun_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing
FACTORY_DEF * TestFactory    FACTORY_NAME Table_Not_Yet_Begun_FeatureDirector    INPUT  FEATURE_TYPE FeatureMerger_NOT_MERGED_1_LpSJBSvR7Fc=    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Table_Not_Yet_Begun___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Table_Not_Yet_Begun___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Table_Not_Yet_Begun___FeatureDirector1    INPUT FEATURE_TYPE Table_Not_Yet_Begun___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Table_Not_Yet_Begun___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Table_Not_Yet_Begun___PointCloudFeatures___
# Vector features simply may get their colors overridden
FACTORY_DEF * TeeFactory    FACTORY_NAME Table_Not_Yet_Begun_VectorSetterUpper    INPUT FEATURE_TYPE Table_Not_Yet_Begun___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned
# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.
Tcl2 proc Table_Not_Yet_Begun_25285ec7_66d1_481b_aa73_3a49e6695c9b0_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Table_Not_Yet_Begun___PointCloudThinner    INPUT FEATURE_TYPE Table_Not_Yet_Begun___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Table_Not_Yet_Begun_25285ec7_66d1_481b_aa73_3a49e6695c9b0_thinPointCloud")
Tcl2 proc Table_Not_Yet_Begun_25285ec7_66d1_481b_aa73_3a49e6695c9b0_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Table_Not_Yet_Begun_RasterSetterUpper    INPUT FEATURE_TYPE Table_Not_Yet_Begun___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Table_Not_Yet_Begun_25285ec7_66d1_481b_aa73_3a49e6695c9b0_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Table_Not_Yet_Begun_25285ec7_66d1_481b_aa73_3a49e6695c9b0_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.
DEFAULT_MACRO Table_Not_Yet_Begun_25285ec7_66d1_481b_aa73_3a49e6695c9b0_VIS_FEAT_TYPE Table_Not_Yet_Begun$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.
FACTORY_DEF * RecorderFactory    FACTORY_NAME Table_Not_Yet_Begun_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Table_Not_Yet_Begun_25285ec7_66d1_481b_aa73_3a49e6695c9b0_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA path_unix,varchar<openparen>255<closeparen>,path_windows,varchar<openparen>255<closeparen>,path_rootname,varchar<openparen>255<closeparen>,path_filename,varchar<openparen>255<closeparen>,path_extension,varchar<openparen>255<closeparen>,path_filesize,varchar<openparen>255<closeparen>,path_ownername,varchar<openparen>255<closeparen>,path_readonly,varchar<openparen>255<closeparen>,path_modified_date,varchar<openparen>255<closeparen>,path_created_date,varchar<openparen>255<closeparen>,path_accessed_date,varchar<openparen>255<closeparen>,path_directory_unix,varchar<openparen>255<closeparen>,path_directory_windows,varchar<openparen>255<closeparen>,path_type,varchar<openparen>255<closeparen>,SurveyID_File,varchar<openparen>255<closeparen>,RecordName_File,varchar<openparen>255<closeparen>,_match_id,varchar<openparen>255<closeparen>    MODE RECORD    STORE_SCANNED_METADATA    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000
# -------------------------------------------------------------------------
FACTORY_DEF * TestFactory    FACTORY_NAME Tester_3    INPUT  FEATURE_TYPE FeatureMerger_NOT_MERGED_0_mc6xVklKjb8=    TEST @EvaluateExpression(FDIV,STRING_ENCODED,$(Load_New_Tables),Tester_3) = 1 ENCODED    BOOLEAN_OPERATOR OR    OUTPUT PASSED FEATURE_TYPE Tester_3_PASSED
FACTORY_DEF * TeeFactory   FACTORY_NAME "Tester_3_PASSED Feature Counter -1 122"   INPUT FEATURE_TYPE Tester_3_PASSED   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 122")
# -------------------------------------------------------------------------
INCLUDE [if { {ATTRIBUTES} == {ATTRIBUTES} } {                puts "MACRO FeatureMerger_2_REFERENCE_INFO ATTRIBUTES";             }          elseif { {ATTRIBUTES} == {GEOM_BUILD} && {<Unused>} == {POLYGONS}} {                puts "MACRO FeatureMerger_2_REFERENCE_INFO GEOM_BUILD_POLYS";             }          elseif { {ATTRIBUTES} == {GEOM_BUILD} && {<Unused>} == {AGGREGATES}} {                puts "MACRO FeatureMerger_2_REFERENCE_INFO GEOM_BUILD_AGGREGATES";             }          elseif { {ATTRIBUTES} == {GEOM_BUILD} && {<Unused>} == {LINESFROMPOINTS}} {                puts "MACRO FeatureMerger_2_REFERENCE_INFO GEOM_BUILD_LINES_FROM_POINTS";             }          elseif { {ATTRIBUTES} == {GEOM_AND_ATTRS} && {<Unused>} == {POLYGONS}} {                puts "MACRO FeatureMerger_2_REFERENCE_INFO GEOM_AND_ATTR_BUILD_POLYS";             }          elseif { {ATTRIBUTES} == {GEOM_AND_ATTRS} && {<Unused>} == {AGGREGATES}} {                puts "MACRO FeatureMerger_2_REFERENCE_INFO GEOM_AND_ATTR_BUILD_AGGREGATES";             }          elseif { {ATTRIBUTES} == {GEOM_AND_ATTRS} && {<Unused>} == {LINESFROMPOINTS}} {                puts "MACRO FeatureMerger_2_REFERENCE_INFO GEOM_AND_ATTR_BUILD_LINES_FROM_POINTS";             }          elseif { {ATTRIBUTES} == {GEOM_BUILD} } {                puts "MACRO FeatureMerger_2_REFERENCE_INFO GEOM_BUILD_AGGREGATES";             }          elseif { {ATTRIBUTES} == {GEOM_AND_ATTRS} } {                puts "MACRO FeatureMerger_2_REFERENCE_INFO GEOM_AND_ATTR_BUILD_AGGREGATES";             }          else {}; ]
FACTORY_DEF {*} ReferenceFactory    FACTORY_NAME FeatureMerger_2    INPUT REFERENCER FEATURE_TYPE FeatureMerger_MERGED    INPUT REFERENCEE FEATURE_TYPE SQLExecutor_2_RESULT    REFERENCE_INFO $(FeatureMerger_2_REFERENCE_INFO)    REFERENCE_TABLE @EvaluateExpression(FDIV,STRING_ENCODED,<at>Value<openparen>SurveyID_File<closeparen>,FeatureMerger_2) @EvaluateExpression(FDIV,STRING_ENCODED,<at>Value<openparen>surveyid<closeparen>,FeatureMerger_2) AUTO @EvaluateExpression(FDIV,STRING_ENCODED,<at>Value<openparen>RecordName_File<closeparen>,FeatureMerger_2) @EvaluateExpression(FDIV,STRING_ENCODED,<at>Value<openparen>table_name<closeparen>,FeatureMerger_2) AUTO    ATTR_ACCUM_MODE "HANDLE_CONFLICT"    ATTR_CONFLICT_RES "REQUESTOR_IF_CONFLICT"    IGNORE_NULLS "No"    HANDLE_NULL_MISSING_KEYS_LIKE_FME2013 No    MERGE_ATTRIBUTES Yes    MANAGE_FME_TYPE Yes    MODE COMPLETE    PROCESS_DUPLICATE_REFERENCEES No    REFERENCEES_FIRST Yes    OUTPUT COMPLETE FEATURE_TYPE FeatureMerger_2_MERGED    OUTPUT INCOMPLETE FEATURE_TYPE FeatureMerger_2_NOT_MERGED
FACTORY_DEF * TeeFactory   FACTORY_NAME "FeatureMerger_2 NOT_MERGED Splitter"   INPUT FEATURE_TYPE FeatureMerger_2_NOT_MERGED   OUTPUT FEATURE_TYPE FeatureMerger_2_NOT_MERGED_0_SP1JlS5M+DE=   OUTPUT FEATURE_TYPE FeatureMerger_2_NOT_MERGED_1_jw3ASBbAEqw=
FACTORY_DEF * TeeFactory   FACTORY_NAME "FeatureMerger_2_MERGED Feature Counter -1 52"   INPUT FEATURE_TYPE FeatureMerger_2_MERGED   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 52")
FACTORY_DEF * TeeFactory   FACTORY_NAME "FeatureMerger_2_NOT_MERGED_0_SP1JlS5M+DE= Feature Counter -1 71"   INPUT FEATURE_TYPE FeatureMerger_2_NOT_MERGED_0_SP1JlS5M+DE=   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 71")
FACTORY_DEF * TeeFactory   FACTORY_NAME "FeatureMerger_2_NOT_MERGED_1_jw3ASBbAEqw= Feature Counter -1 72"   INPUT FEATURE_TYPE FeatureMerger_2_NOT_MERGED_1_jw3ASBbAEqw=   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 72")
# -------------------------------------------------------------------------
FACTORY_DEF {*} AttrSetFactory    FACTORY_NAME AttributeCopier    INPUT  FEATURE_TYPE Tester_3_PASSED    INPUT  FEATURE_TYPE FeatureMerger_2_NOT_MERGED_1_jw3ASBbAEqw= 	 ATTRSET_CREATE_DIRECTIVES _PROPAGATE_MISSING_FDIV 	 ATTR_ACTION { "RecordName_File" "table_name" "COPY" "" }      ATTR_ACTION { "SurveyID_File" "surveyid" "COPY" "" }    OUTPUT OUTPUT FEATURE_TYPE AttributeCopier_OUTPUT
FACTORY_DEF * TeeFactory   FACTORY_NAME "AttributeCopier_OUTPUT Feature Counter -1 61"   INPUT FEATURE_TYPE AttributeCopier_OUTPUT   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 61")
# -------------------------------------------------------------------------
# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.
READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {File_Adding_To_Table} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME File_Adding_To_Table_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME File_Adding_To_Table_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing
FACTORY_DEF * TestFactory    FACTORY_NAME File_Adding_To_Table_FeatureDirector    INPUT  FEATURE_TYPE FeatureMerger_2_NOT_MERGED_0_SP1JlS5M+DE=    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE File_Adding_To_Table___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE File_Adding_To_Table___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME File_Adding_To_Table___FeatureDirector1    INPUT FEATURE_TYPE File_Adding_To_Table___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE File_Adding_To_Table___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE File_Adding_To_Table___PointCloudFeatures___
# Vector features simply may get their colors overridden
FACTORY_DEF * TeeFactory    FACTORY_NAME File_Adding_To_Table_VectorSetterUpper    INPUT FEATURE_TYPE File_Adding_To_Table___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned
# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.
Tcl2 proc File_Adding_To_Table_c48bddbc_9491_419f_8e55_838c12cc6f700_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME File_Adding_To_Table___PointCloudThinner    INPUT FEATURE_TYPE File_Adding_To_Table___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("File_Adding_To_Table_c48bddbc_9491_419f_8e55_838c12cc6f700_thinPointCloud")
Tcl2 proc File_Adding_To_Table_c48bddbc_9491_419f_8e55_838c12cc6f700_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME File_Adding_To_Table_RasterSetterUpper    INPUT FEATURE_TYPE File_Adding_To_Table___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("File_Adding_To_Table_c48bddbc_9491_419f_8e55_838c12cc6f700_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# File_Adding_To_Table_c48bddbc_9491_419f_8e55_838c12cc6f700_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.
DEFAULT_MACRO File_Adding_To_Table_c48bddbc_9491_419f_8e55_838c12cc6f700_VIS_FEAT_TYPE File_Adding_To_Table$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.
FACTORY_DEF * RecorderFactory    FACTORY_NAME File_Adding_To_Table_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(File_Adding_To_Table_c48bddbc_9491_419f_8e55_838c12cc6f700_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA path_unix,varchar<openparen>255<closeparen>,path_windows,varchar<openparen>255<closeparen>,path_rootname,varchar<openparen>255<closeparen>,path_filename,varchar<openparen>255<closeparen>,path_extension,varchar<openparen>255<closeparen>,path_filesize,varchar<openparen>255<closeparen>,path_ownername,varchar<openparen>255<closeparen>,path_readonly,varchar<openparen>255<closeparen>,path_modified_date,varchar<openparen>255<closeparen>,path_created_date,varchar<openparen>255<closeparen>,path_accessed_date,varchar<openparen>255<closeparen>,path_directory_unix,varchar<openparen>255<closeparen>,path_directory_windows,varchar<openparen>255<closeparen>,path_type,varchar<openparen>255<closeparen>,SurveyID_File,varchar<openparen>255<closeparen>,RecordName_File,varchar<openparen>255<closeparen>,_match_id,varchar<openparen>255<closeparen>,table_name,varchar<openparen>255<closeparen>    MODE RECORD    STORE_SCANNED_METADATA    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000
# -------------------------------------------------------------------------
FME_PYTHON_PATH "$(FME_MF_DIR)"
FACTORY_DEF * PythonFactory    FACTORY_NAME PythonCaller    INPUT  FEATURE_TYPE FeatureMerger_2_MERGED    SYMBOL_NAME FeatureProcessor    PYTHON_NAMESPACE FMEOBJECTS    SOURCE_CODE import<space>fme<lf>import<space>fmeobjects<lf>#<space>Template<space>Function<space>interface:<lf>#<space>When<space>using<space>this<space>function<comma><space>make<space>sure<space>its<space>name<space>is<space>set<space>as<space>the<space>value<space>of<lf>#<space>the<space><apos>Class<space>or<space>Function<space>to<space>Process<space>Features<apos><space>transformer<space>parameter<lf>def<space>processFeature<openparen>feature<closeparen>:<lf><space><space><space><space>pass<lf><lf>#<space>Template<space>Class<space>Interface:<lf>#<space>When<space>using<space>this<space>class<comma><space>make<space>sure<space>its<space>name<space>is<space>set<space>as<space>the<space>value<space>of<lf>#<space>the<space><apos>Class<space>or<space>Function<space>to<space>Process<space>Features<apos><space>transformer<space>parameter<lf>class<space>FeatureProcessor<openparen>object<closeparen>:<lf><space><space><space><space>def<space>__init__<openparen>self<closeparen>:<lf><space><space><space><space><space><space><space><space>pass<lf><space><space><space><space>def<space>input<openparen>self<comma>feature<closeparen>:<lf><space><space><space><space><space><space><space><space>with<space>open<space><openparen>feature.getAttribute<openparen><apos>path_windows<apos><closeparen><closeparen><space>as<space>f:<lf><space><space><space><space><space><space><space><space><space><space><space><space>for<space>i<comma>l<space>in<space>enumerate<openparen>f<closeparen>:<lf><space><space><space><space><space><space><space><space><space><space><space><space><space><space><space><space>pass<lf><space><space><space><space><space><space><space><space>#<space>nrows<space>will<space>be<space>i+1<space>but<space>we<space>want<space>to<space>discard<space>1<space><openparen>the<space>header<closeparen><lf><space><space><space><space><space><space><space><space>feature.setAttribute<openparen><quote>nrows_file<quote><comma><space>i<closeparen><lf><space><space><space><space><space><space><space><space>self.pyoutput<openparen>feature<closeparen><lf><space><space><space><space>def<space>close<openparen>self<closeparen>:<lf><space><space><space><space><space><space><space><space>pass    OUTPUT PYOUTPUT FEATURE_TYPE PythonCaller_OUTPUT
FACTORY_DEF * TeeFactory   FACTORY_NAME "PythonCaller_OUTPUT Feature Counter -1 54"   INPUT FEATURE_TYPE PythonCaller_OUTPUT   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 54")
# -------------------------------------------------------------------------
FACTORY_DEF * TestFactory    FACTORY_NAME Tester_2    INPUT  FEATURE_TYPE PythonCaller_OUTPUT    TEST @EvaluateExpression(FDIV,STRING_ENCODED,<at>Value<openparen>nrows_file<closeparen>,Tester_2) = @EvaluateExpression(FDIV,STRING_ENCODED,<at>Value<openparen>nrows_db<closeparen>,Tester_2) ENCODED TEST @EvaluateExpression(FDIV,STRING_ENCODED,$(Force_Reload_Existing),Tester_2) = 0 ENCODED    BOOLEAN_OPERATOR AND    OUTPUT PASSED FEATURE_TYPE Tester_2_PASSED    OUTPUT FAILED FEATURE_TYPE Tester_2_FAILED
FACTORY_DEF * TeeFactory   FACTORY_NAME "Tester_2 FAILED Splitter"   INPUT FEATURE_TYPE Tester_2_FAILED   OUTPUT FEATURE_TYPE Tester_2_FAILED_0_52RatjfZRx8=   OUTPUT FEATURE_TYPE Tester_2_FAILED_1_z/q1qWuo7hw=
FACTORY_DEF * TeeFactory   FACTORY_NAME "Tester_2_PASSED Feature Counter -1 55"   INPUT FEATURE_TYPE Tester_2_PASSED   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 55")
FACTORY_DEF * TeeFactory   FACTORY_NAME "Tester_2_FAILED_0_52RatjfZRx8= Feature Counter -1 74"   INPUT FEATURE_TYPE Tester_2_FAILED_0_52RatjfZRx8=   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 74")
FACTORY_DEF * TeeFactory   FACTORY_NAME "Tester_2_FAILED_1_z/q1qWuo7hw= Feature Counter -1 75"   INPUT FEATURE_TYPE Tester_2_FAILED_1_z/q1qWuo7hw=   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 75")
# -------------------------------------------------------------------------
# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.
READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Table_CSV_Needs_Reloading} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Table_CSV_Needs_Reloading_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Table_CSV_Needs_Reloading_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing
FACTORY_DEF * TestFactory    FACTORY_NAME Table_CSV_Needs_Reloading_FeatureDirector    INPUT  FEATURE_TYPE Tester_2_FAILED_0_52RatjfZRx8=    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Table_CSV_Needs_Reloading___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Table_CSV_Needs_Reloading___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Table_CSV_Needs_Reloading___FeatureDirector1    INPUT FEATURE_TYPE Table_CSV_Needs_Reloading___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Table_CSV_Needs_Reloading___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Table_CSV_Needs_Reloading___PointCloudFeatures___
# Vector features simply may get their colors overridden
FACTORY_DEF * TeeFactory    FACTORY_NAME Table_CSV_Needs_Reloading_VectorSetterUpper    INPUT FEATURE_TYPE Table_CSV_Needs_Reloading___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned
# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.
Tcl2 proc Table_CSV_Needs_Reloading_cca7fcda_7048_41e7_8523_4b6b7f3b4ca10_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Table_CSV_Needs_Reloading___PointCloudThinner    INPUT FEATURE_TYPE Table_CSV_Needs_Reloading___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Table_CSV_Needs_Reloading_cca7fcda_7048_41e7_8523_4b6b7f3b4ca10_thinPointCloud")
Tcl2 proc Table_CSV_Needs_Reloading_cca7fcda_7048_41e7_8523_4b6b7f3b4ca10_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Table_CSV_Needs_Reloading_RasterSetterUpper    INPUT FEATURE_TYPE Table_CSV_Needs_Reloading___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Table_CSV_Needs_Reloading_cca7fcda_7048_41e7_8523_4b6b7f3b4ca10_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Table_CSV_Needs_Reloading_cca7fcda_7048_41e7_8523_4b6b7f3b4ca10_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.
DEFAULT_MACRO Table_CSV_Needs_Reloading_cca7fcda_7048_41e7_8523_4b6b7f3b4ca10_VIS_FEAT_TYPE Table_CSV_Needs_Reloading$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.
FACTORY_DEF * RecorderFactory    FACTORY_NAME Table_CSV_Needs_Reloading_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Table_CSV_Needs_Reloading_cca7fcda_7048_41e7_8523_4b6b7f3b4ca10_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA path_unix,varchar<openparen>255<closeparen>,path_windows,varchar<openparen>255<closeparen>,path_rootname,varchar<openparen>255<closeparen>,path_filename,varchar<openparen>255<closeparen>,path_extension,varchar<openparen>255<closeparen>,path_filesize,varchar<openparen>255<closeparen>,path_ownername,varchar<openparen>255<closeparen>,path_readonly,varchar<openparen>255<closeparen>,path_modified_date,varchar<openparen>255<closeparen>,path_created_date,varchar<openparen>255<closeparen>,path_accessed_date,varchar<openparen>255<closeparen>,path_directory_unix,varchar<openparen>255<closeparen>,path_directory_windows,varchar<openparen>255<closeparen>,path_type,varchar<openparen>255<closeparen>,SurveyID_File,varchar<openparen>255<closeparen>,RecordName_File,varchar<openparen>255<closeparen>,_match_id,varchar<openparen>255<closeparen>,table_name,varchar<openparen>255<closeparen>,surveyid,varchar<openparen>255<closeparen>,nrows_db,varchar<openparen>255<closeparen>,nrows_file,varchar<openparen>255<closeparen>    MODE RECORD    STORE_SCANNED_METADATA    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000
# -------------------------------------------------------------------------
INCLUDE [if { {ATTRIBUTES} == {ATTRIBUTES} } {                puts "MACRO FeatureMerger_4_REFERENCE_INFO ATTRIBUTES";             }          elseif { {ATTRIBUTES} == {GEOM_BUILD} && {<Unused>} == {POLYGONS}} {                puts "MACRO FeatureMerger_4_REFERENCE_INFO GEOM_BUILD_POLYS";             }          elseif { {ATTRIBUTES} == {GEOM_BUILD} && {<Unused>} == {AGGREGATES}} {                puts "MACRO FeatureMerger_4_REFERENCE_INFO GEOM_BUILD_AGGREGATES";             }          elseif { {ATTRIBUTES} == {GEOM_BUILD} && {<Unused>} == {LINESFROMPOINTS}} {                puts "MACRO FeatureMerger_4_REFERENCE_INFO GEOM_BUILD_LINES_FROM_POINTS";             }          elseif { {ATTRIBUTES} == {GEOM_AND_ATTRS} && {<Unused>} == {POLYGONS}} {                puts "MACRO FeatureMerger_4_REFERENCE_INFO GEOM_AND_ATTR_BUILD_POLYS";             }          elseif { {ATTRIBUTES} == {GEOM_AND_ATTRS} && {<Unused>} == {AGGREGATES}} {                puts "MACRO FeatureMerger_4_REFERENCE_INFO GEOM_AND_ATTR_BUILD_AGGREGATES";             }          elseif { {ATTRIBUTES} == {GEOM_AND_ATTRS} && {<Unused>} == {LINESFROMPOINTS}} {                puts "MACRO FeatureMerger_4_REFERENCE_INFO GEOM_AND_ATTR_BUILD_LINES_FROM_POINTS";             }          elseif { {ATTRIBUTES} == {GEOM_BUILD} } {                puts "MACRO FeatureMerger_4_REFERENCE_INFO GEOM_BUILD_AGGREGATES";             }          elseif { {ATTRIBUTES} == {GEOM_AND_ATTRS} } {                puts "MACRO FeatureMerger_4_REFERENCE_INFO GEOM_AND_ATTR_BUILD_AGGREGATES";             }          else {}; ]
FACTORY_DEF {*} ReferenceFactory    FACTORY_NAME FeatureMerger_4    INPUT REFERENCER FEATURE_TYPE Tester_2_PASSED    INPUT REFERENCEE FEATURE_TYPE CSV_CSV2_1    REFERENCE_INFO $(FeatureMerger_4_REFERENCE_INFO)    REFERENCE_TABLE @EvaluateExpression(FDIV,STRING_ENCODED,<at>Value<openparen>surveyid<closeparen>,FeatureMerger_4) @EvaluateExpression(FDIV,STRING_ENCODED,<at>Value<openparen>surveyid<closeparen>,FeatureMerger_4) AUTO @EvaluateExpression(FDIV,STRING_ENCODED,<at>Value<openparen>RecordName_File<closeparen>,FeatureMerger_4) @EvaluateExpression(FDIV,STRING_ENCODED,<at>Value<openparen>recordname<closeparen>,FeatureMerger_4) AUTO    ATTR_ACCUM_MODE "HANDLE_CONFLICT"    ATTR_CONFLICT_RES "REQUESTOR_IF_CONFLICT"    IGNORE_NULLS "No"    HANDLE_NULL_MISSING_KEYS_LIKE_FME2013 No    LIST_ATTRS_TO_INCLUDE { <Unused> }    LIST_ATTRS_TO_INCLUDE_MODE <Unused>    MERGE_ATTRIBUTES Yes    MANAGE_FME_TYPE Yes    MODE COMPLETE    PROCESS_DUPLICATE_REFERENCEES No    REFERENCEES_FIRST No    REJECT_INVALID_GEOM YES    CLEANING_TOLERANCE NONE    OUTPUT COMPLETE FEATURE_TYPE FeatureMerger_4_MERGED    OUTPUT INCOMPLETE FEATURE_TYPE FeatureMerger_4_UNMERGED_REQUESTOR    OUTPUT REJECTED FEATURE_TYPE FeatureMerger_4_<REJECTED>
FACTORY_DEF * TeeFactory   FACTORY_NAME "FeatureMerger_4 MERGED Splitter"   INPUT FEATURE_TYPE FeatureMerger_4_MERGED   OUTPUT FEATURE_TYPE FeatureMerger_4_MERGED_0_MPdsV4kZqGg=   OUTPUT FEATURE_TYPE FeatureMerger_4_MERGED_1_z9LIgn1J5wc=
FACTORY_DEF * TeeFactory   FACTORY_NAME "FeatureMerger_4_MERGED_0_MPdsV4kZqGg= Feature Counter -1 64"   INPUT FEATURE_TYPE FeatureMerger_4_MERGED_0_MPdsV4kZqGg=   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 64")
FACTORY_DEF * TeeFactory   FACTORY_NAME "FeatureMerger_4_MERGED_1_z9LIgn1J5wc= Feature Counter -1 65"   INPUT FEATURE_TYPE FeatureMerger_4_MERGED_1_z9LIgn1J5wc=   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 65")
FACTORY_DEF * TeeFactory   FACTORY_NAME "FeatureMerger_4_UNMERGED_REQUESTOR Feature Counter -1 79"   INPUT FEATURE_TYPE FeatureMerger_4_UNMERGED_REQUESTOR   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 79")
FACTORY_DEF * TeeFactory   FACTORY_NAME "FeatureMerger_4_<REJECTED> Feature Counter -1 102"   INPUT FEATURE_TYPE FeatureMerger_4_<REJECTED>   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 102")
# -------------------------------------------------------------------------
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [    set safeName "[regsub -all {[^a-zA-Z0-9]} {Extra_Cols_GT1PerTable} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";    puts "MACRO SAFE_FFS_NAME $safeName"; ]
FACTORY_DEF {*} InspectorFactory    FACTORY_NAME Extra_Cols_GT1PerTable_Prepper    COMMAND_PARM_EVALUATION SINGLE_PASS    INPUT  FEATURE_TYPE FeatureMerger_4_<REJECTED>    GROUP_ATTRIBUTE __inspector_feature_type_attr__    GROUP_BY {  }    GROUP_ATTRIBUTE_PREFIX { Extra_Cols_GT1PerTable }    RASTER_REDUCTION NoReduction    POINT_CLOUD_REDUCTION NO_THINNING    OUTPUT RESULT FEATURE_TYPE __viewme__
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.
FACTORY_DEF * RecorderFactory    FACTORY_NAME Extra_Cols_GT1PerTable_Recorder    COMMAND_PARM_EVALUATION SINGLE_PASS    INPUT FEATURE_TYPE __viewme__       _wb_termination_feature Yes       @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__       @FeatureType(@Value(__inspector_feature_type_attr__))       @RemoveAttributes(__inspector_feature_type_attr__)    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    STORE_SCANNED_SCHEMA YES    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA path_unix,varchar<openparen>255<closeparen>,path_windows,varchar<openparen>255<closeparen>,path_rootname,varchar<openparen>255<closeparen>,path_filename,varchar<openparen>255<closeparen>,path_extension,varchar<openparen>255<closeparen>,path_filesize,varchar<openparen>255<closeparen>,path_ownername,varchar<openparen>255<closeparen>,path_readonly,varchar<openparen>255<closeparen>,path_modified_date,varchar<openparen>255<closeparen>,path_created_date,varchar<openparen>255<closeparen>,path_accessed_date,varchar<openparen>255<closeparen>,path_directory_unix,varchar<openparen>255<closeparen>,path_directory_windows,varchar<openparen>255<closeparen>,path_type,varchar<openparen>255<closeparen>,SurveyID_File,varchar<openparen>255<closeparen>,RecordName_File,varchar<openparen>255<closeparen>,_match_id,varchar<openparen>255<closeparen>,table_name,varchar<openparen>255<closeparen>,surveyid,varchar<openparen>255<closeparen>,nrows_db,varchar<openparen>255<closeparen>,nrows_file,varchar<openparen>255<closeparen>,maxlen,varchar<openparen>255<closeparen>,name,varchar<openparen>255<closeparen>,recordname,varchar<openparen>255<closeparen>,fme_rejection_code,varchar<openparen>255<closeparen>    MODE RECORD    STORE_SCANNED_METADATA    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000
# -------------------------------------------------------------------------
# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.
READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {File_Already_Loaded} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME File_Already_Loaded_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME File_Already_Loaded_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing
FACTORY_DEF * TestFactory    FACTORY_NAME File_Already_Loaded_FeatureDirector    INPUT  FEATURE_TYPE FeatureMerger_4_UNMERGED_REQUESTOR    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE File_Already_Loaded___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE File_Already_Loaded___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME File_Already_Loaded___FeatureDirector1    INPUT FEATURE_TYPE File_Already_Loaded___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE File_Already_Loaded___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE File_Already_Loaded___PointCloudFeatures___
# Vector features simply may get their colors overridden
FACTORY_DEF * TeeFactory    FACTORY_NAME File_Already_Loaded_VectorSetterUpper    INPUT FEATURE_TYPE File_Already_Loaded___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned
# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.
Tcl2 proc File_Already_Loaded_3e25f764_3b52_455a_a378_3ccbd1e636d80_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME File_Already_Loaded___PointCloudThinner    INPUT FEATURE_TYPE File_Already_Loaded___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("File_Already_Loaded_3e25f764_3b52_455a_a378_3ccbd1e636d80_thinPointCloud")
Tcl2 proc File_Already_Loaded_3e25f764_3b52_455a_a378_3ccbd1e636d80_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME File_Already_Loaded_RasterSetterUpper    INPUT FEATURE_TYPE File_Already_Loaded___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("File_Already_Loaded_3e25f764_3b52_455a_a378_3ccbd1e636d80_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# File_Already_Loaded_3e25f764_3b52_455a_a378_3ccbd1e636d80_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.
DEFAULT_MACRO File_Already_Loaded_3e25f764_3b52_455a_a378_3ccbd1e636d80_VIS_FEAT_TYPE File_Already_Loaded$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.
FACTORY_DEF * RecorderFactory    FACTORY_NAME File_Already_Loaded_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(File_Already_Loaded_3e25f764_3b52_455a_a378_3ccbd1e636d80_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA path_unix,varchar<openparen>255<closeparen>,path_windows,varchar<openparen>255<closeparen>,path_rootname,varchar<openparen>255<closeparen>,path_filename,varchar<openparen>255<closeparen>,path_extension,varchar<openparen>255<closeparen>,path_filesize,varchar<openparen>255<closeparen>,path_ownername,varchar<openparen>255<closeparen>,path_readonly,varchar<openparen>255<closeparen>,path_modified_date,varchar<openparen>255<closeparen>,path_created_date,varchar<openparen>255<closeparen>,path_accessed_date,varchar<openparen>255<closeparen>,path_directory_unix,varchar<openparen>255<closeparen>,path_directory_windows,varchar<openparen>255<closeparen>,path_type,varchar<openparen>255<closeparen>,SurveyID_File,varchar<openparen>255<closeparen>,RecordName_File,varchar<openparen>255<closeparen>,_match_id,varchar<openparen>255<closeparen>,table_name,varchar<openparen>255<closeparen>,surveyid,varchar<openparen>255<closeparen>,nrows_db,varchar<openparen>255<closeparen>,nrows_file,varchar<openparen>255<closeparen>    MODE RECORD    STORE_SCANNED_METADATA    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000
# -------------------------------------------------------------------------
MACRO SQLExecutor_DIRECTIVES QUERY_FEATURE_TYPES_FOR_MERGE_FILTERS Yes SCHEMAS_FOR_TABLE_LISTING dhs_data_tables NAMED_CONNECTION Admin<space>on<space>MAP-FS1<space><openparen>DHS<space>instance<closeparen>
FACTORY_DEF * QueryFactory    FACTORY_NAME SQLExecutor    INPUT  FEATURE_TYPE FeatureMerger_4_MERGED_1_z9LIgn1J5wc=    INPUT  FEATURE_TYPE Tester_2_FAILED_1_z/q1qWuo7hw=    QUERY_SQL            "@EvaluateExpression(FDIV,STRING_ENCODED,DELETE<space>FROM<space><space>dhs_data_tables.<quote><at>Value<openparen>table_name<closeparen><quote><space>WHERE<space>surveyid<space>=<space><apos><at>Value<openparen>surveyid<closeparen><apos>,SQLExecutor)"    READER_TYPE          POSTGRES    READER_DATASET       "Admin<space>on<space>MAP-FS1<space><openparen>DHS<space>instance<closeparen>"    COMBINE_ATTRIBUTES   PREFER_QUERY    COMBINE_GEOMETRY     QUERY_ONLY    CONTINUE_ON_READER_ERROR YES    QUERYFCT_PROPAGATE_IDS_ON_SQL_EXECUTE YES    READER_PARAMS        $(SQLExecutor_DIRECTIVES)    OUTPUT RESULT FEATURE_TYPE SQLExecutor_RESULT    OUTPUT QUERY FEATURE_TYPE SQLExecutor_INITIATOR    OUTPUT READER_ERROR FEATURE_TYPE SQLExecutor_<REJECTED>
FACTORY_DEF * TeeFactory   FACTORY_NAME "SQLExecutor RESULT Transformer Output Nuker"   INPUT FEATURE_TYPE SQLExecutor_RESULT
FACTORY_DEF * RecorderFactory FACTORY_NAME "SQLExecutor_<REJECTED> Feature Recorder -1 2147745814" INPUT FEATURE_TYPE SQLExecutor_<REJECTED> FEATURE_FILE "C:/Users/ZOOL13~1.NDP/AppData/Local/Temp/wb-cache-Load_DHS_Data_To_PG_With_Checks-F34608/Main_SQLExecutor -1 22 fo 2 _lt_REJECTED_gt_  0  08e938b5018dbe136976302b6a44c7f8e86978ad.ffsupdating" MODE RECORD_PASS_THROUGH STORE_SCANNED_SCHEMA YES CREATE_SPATIAL_INDEX YES INSPECTOR YES RECORD_DIRECTLY_TO_DISK YES FSC_SCHEMA path_unix,varchar<openparen>255<closeparen>,path_windows,varchar<openparen>255<closeparen>,path_rootname,varchar<openparen>255<closeparen>,path_filename,varchar<openparen>255<closeparen>,path_extension,varchar<openparen>255<closeparen>,path_filesize,varchar<openparen>255<closeparen>,path_ownername,varchar<openparen>255<closeparen>,path_readonly,varchar<openparen>255<closeparen>,path_modified_date,varchar<openparen>255<closeparen>,path_created_date,varchar<openparen>255<closeparen>,path_accessed_date,varchar<openparen>255<closeparen>,path_directory_unix,varchar<openparen>255<closeparen>,path_directory_windows,varchar<openparen>255<closeparen>,path_type,varchar<openparen>255<closeparen>,SurveyID_File,varchar<openparen>255<closeparen>,RecordName_File,varchar<openparen>255<closeparen>,_match_id,varchar<openparen>255<closeparen>,table_name,varchar<openparen>255<closeparen>,surveyid,varchar<openparen>255<closeparen>,nrows_db,varchar<openparen>255<closeparen>,nrows_file,varchar<openparen>255<closeparen>,maxlen,varchar<openparen>255<closeparen>,name,varchar<openparen>255<closeparen>,recordname,varchar<openparen>255<closeparen>,_reader_error,varchar<openparen>255<closeparen> STORE_SCANNED_METADATA PASS_THROUGH_FME_TYPE OUTPUT RECORDED FEATURE_TYPE *
FACTORY_DEF * TeeFactory   FACTORY_NAME "SQLExecutor_INITIATOR Feature Counter -1 76"   INPUT FEATURE_TYPE SQLExecutor_INITIATOR   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 76")
FACTORY_DEF * TeeFactory   FACTORY_NAME "SQLExecutor_<REJECTED> Feature Counter -1 2147745814"   INPUT FEATURE_TYPE SQLExecutor_<REJECTED>     @LogCount("PORT -1 2147745814")
# -------------------------------------------------------------------------
INCLUDE [    set macroLine "MACRO AttributeKeeper_42571e69_f535_4187_bc2a_559a43b070a70_LIST_EXP ";    foreach attr [split ""] {       set attr [FME_DecodeText $attr];       set attr [regsub "{}$" $attr "{}.*"];       set attr [regsub -all "{}" $attr "\\{\[0-9\]+\\}"];       append macroLine ",^$attr$";    };    puts $macroLine; ]
FACTORY_DEF {*} TeeFactory    FACTORY_NAME AttributeKeeper    INPUT  FEATURE_TYPE AttributeCopier_OUTPUT    INPUT  FEATURE_TYPE SQLExecutor_INITIATOR    OUTPUT { FEATURE_TYPE AttributeKeeper_OUTPUT        @KeepAttributes(fme_encoded,surveyid,path_windows,table_name,fme_pcre_match,"^fme_$(AttributeKeeper_42571e69_f535_4187_bc2a_559a43b070a70_LIST_EXP)")         }
FACTORY_DEF * TeeFactory   FACTORY_NAME "AttributeKeeper_OUTPUT Feature Counter -1 57"   INPUT FEATURE_TYPE AttributeKeeper_OUTPUT   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 57")
# -------------------------------------------------------------------------
INCLUDE [if { {ATTRIBUTES} == {ATTRIBUTES} } {                puts "MACRO FeatureMerger_3_REFERENCE_INFO ATTRIBUTES";             }          elseif { {ATTRIBUTES} == {GEOM_BUILD} && {<Unused>} == {POLYGONS}} {                puts "MACRO FeatureMerger_3_REFERENCE_INFO GEOM_BUILD_POLYS";             }          elseif { {ATTRIBUTES} == {GEOM_BUILD} && {<Unused>} == {AGGREGATES}} {                puts "MACRO FeatureMerger_3_REFERENCE_INFO GEOM_BUILD_AGGREGATES";             }          elseif { {ATTRIBUTES} == {GEOM_BUILD} && {<Unused>} == {LINESFROMPOINTS}} {                puts "MACRO FeatureMerger_3_REFERENCE_INFO GEOM_BUILD_LINES_FROM_POINTS";             }          elseif { {ATTRIBUTES} == {GEOM_AND_ATTRS} && {<Unused>} == {POLYGONS}} {                puts "MACRO FeatureMerger_3_REFERENCE_INFO GEOM_AND_ATTR_BUILD_POLYS";             }          elseif { {ATTRIBUTES} == {GEOM_AND_ATTRS} && {<Unused>} == {AGGREGATES}} {                puts "MACRO FeatureMerger_3_REFERENCE_INFO GEOM_AND_ATTR_BUILD_AGGREGATES";             }          elseif { {ATTRIBUTES} == {GEOM_AND_ATTRS} && {<Unused>} == {LINESFROMPOINTS}} {                puts "MACRO FeatureMerger_3_REFERENCE_INFO GEOM_AND_ATTR_BUILD_LINES_FROM_POINTS";             }          elseif { {ATTRIBUTES} == {GEOM_BUILD} } {                puts "MACRO FeatureMerger_3_REFERENCE_INFO GEOM_BUILD_AGGREGATES";             }          elseif { {ATTRIBUTES} == {GEOM_AND_ATTRS} } {                puts "MACRO FeatureMerger_3_REFERENCE_INFO GEOM_AND_ATTR_BUILD_AGGREGATES";             }          else {}; ]
FACTORY_DEF {*} ReferenceFactory    FACTORY_NAME FeatureMerger_3    INPUT REFERENCER FEATURE_TYPE AttributeKeeper_OUTPUT    INPUT REFERENCEE FEATURE_TYPE AttributeManager_3_OUTPUT    INPUT REFERENCEE FEATURE_TYPE AttributeManager_4_OUTPUT    REFERENCE_INFO $(FeatureMerger_3_REFERENCE_INFO)    REFERENCE_TABLE @EvaluateExpression(FDIV,STRING_ENCODED,<at>Value<openparen>table_name<closeparen>,FeatureMerger_3) @EvaluateExpression(FDIV,STRING_ENCODED,<at>Value<openparen>RecordName<closeparen>,FeatureMerger_3) AUTO    ATTR_ACCUM_MODE "HANDLE_CONFLICT"    ATTR_CONFLICT_RES "REQUESTOR_IF_CONFLICT"    IGNORE_NULLS "No"    HANDLE_NULL_MISSING_KEYS_LIKE_FME2013 No    MERGE_ATTRIBUTES Yes    MANAGE_FME_TYPE Yes    MODE COMPLETE    PROCESS_DUPLICATE_REFERENCEES No    REFERENCEES_FIRST No    OUTPUT COMPLETE FEATURE_TYPE FeatureMerger_3_MERGED    OUTPUT INCOMPLETE FEATURE_TYPE FeatureMerger_3_NOT_MERGED
FACTORY_DEF * TeeFactory   FACTORY_NAME "FeatureMerger_3_MERGED Feature Counter -1 146"   INPUT FEATURE_TYPE FeatureMerger_3_MERGED   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 146")
FACTORY_DEF * TeeFactory   FACTORY_NAME "FeatureMerger_3_NOT_MERGED Feature Counter -1 168"   INPUT FEATURE_TYPE FeatureMerger_3_NOT_MERGED   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 168")
# -------------------------------------------------------------------------
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [    set safeName "[regsub -all {[^a-zA-Z0-9]} {Schema_Search_Error} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";    puts "MACRO SAFE_FFS_NAME $safeName"; ]
FACTORY_DEF {*} InspectorFactory    FACTORY_NAME Schema_Search_Error_Prepper    COMMAND_PARM_EVALUATION SINGLE_PASS    INPUT  FEATURE_TYPE FeatureMerger_3_NOT_MERGED    GROUP_ATTRIBUTE __inspector_feature_type_attr__    GROUP_BY {  }    GROUP_ATTRIBUTE_PREFIX { Schema_Search_Error }    RASTER_REDUCTION NoReduction    POINT_CLOUD_REDUCTION NO_THINNING    OUTPUT RESULT FEATURE_TYPE __viewme__
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.
FACTORY_DEF * RecorderFactory    FACTORY_NAME Schema_Search_Error_Recorder    COMMAND_PARM_EVALUATION SINGLE_PASS    INPUT FEATURE_TYPE __viewme__       _wb_termination_feature Yes       @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__       @FeatureType(@Value(__inspector_feature_type_attr__))       @RemoveAttributes(__inspector_feature_type_attr__)    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    STORE_SCANNED_SCHEMA YES    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA table_name,varchar<openparen>255<closeparen>,surveyid,varchar<openparen>255<closeparen>,path_windows,varchar<openparen>255<closeparen>    MODE RECORD    STORE_SCANNED_METADATA    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000
# -------------------------------------------------------------------------
FACTORY_DEF * TestFactory    FACTORY_NAME Tester_5    INPUT  FEATURE_TYPE FeatureMerger_3_MERGED    TEST @EvaluateExpression(FDIV,STRING_ENCODED,<at>Value<openparen>_is_json<closeparen>,Tester_5) = 0 ENCODED TEST @EvaluateExpression(FDIV,STRING_ENCODED,<at>Value<openparen>table_name<closeparen>,Tester_5) != RECH4 ENCODED    BOOLEAN_OPERATOR AND    OUTPUT PASSED FEATURE_TYPE Tester_5_PASSED    OUTPUT FAILED FEATURE_TYPE Tester_5_FAILED
FACTORY_DEF * TeeFactory   FACTORY_NAME "Tester_5 PASSED Splitter"   INPUT FEATURE_TYPE Tester_5_PASSED   OUTPUT FEATURE_TYPE Tester_5_PASSED_0_OWdaF3NzV3Q=   OUTPUT FEATURE_TYPE Tester_5_PASSED_1_hayxW2aoLHY=
FACTORY_DEF * TeeFactory   FACTORY_NAME "Tester_5 FAILED Splitter"   INPUT FEATURE_TYPE Tester_5_FAILED   OUTPUT FEATURE_TYPE Tester_5_FAILED_0_UcZc14KBmAs=   OUTPUT FEATURE_TYPE Tester_5_FAILED_1_iJgLzUFBpg8=   OUTPUT FEATURE_TYPE Tester_5_FAILED_2_sBlGIaQhiac=
FACTORY_DEF * TeeFactory   FACTORY_NAME "Tester_5_PASSED_0_OWdaF3NzV3Q= Feature Counter -1 147"   INPUT FEATURE_TYPE Tester_5_PASSED_0_OWdaF3NzV3Q=   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 147")
FACTORY_DEF * TeeFactory   FACTORY_NAME "Tester_5_PASSED_1_hayxW2aoLHY= Feature Counter -1 59"   INPUT FEATURE_TYPE Tester_5_PASSED_1_hayxW2aoLHY=   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 59")
FACTORY_DEF * TeeFactory   FACTORY_NAME "Tester_5_FAILED_0_UcZc14KBmAs= Feature Counter -1 153"   INPUT FEATURE_TYPE Tester_5_FAILED_0_UcZc14KBmAs=   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 153")
FACTORY_DEF * TeeFactory   FACTORY_NAME "Tester_5_FAILED_1_iJgLzUFBpg8= Feature Counter -1 165"   INPUT FEATURE_TYPE Tester_5_FAILED_1_iJgLzUFBpg8=   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 165")
FACTORY_DEF * TeeFactory   FACTORY_NAME "Tester_5_FAILED_2_sBlGIaQhiac= Feature Counter -1 166"   INPUT FEATURE_TYPE Tester_5_FAILED_2_sBlGIaQhiac=   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 166")
# -------------------------------------------------------------------------
# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.
READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Files_To_Load_JSON} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Files_To_Load_JSON_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Files_To_Load_JSON_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing
FACTORY_DEF * TestFactory    FACTORY_NAME Files_To_Load_JSON_FeatureDirector    INPUT  FEATURE_TYPE Tester_5_FAILED_1_iJgLzUFBpg8=    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Files_To_Load_JSON___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Files_To_Load_JSON___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Files_To_Load_JSON___FeatureDirector1    INPUT FEATURE_TYPE Files_To_Load_JSON___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Files_To_Load_JSON___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Files_To_Load_JSON___PointCloudFeatures___
# Vector features simply may get their colors overridden
FACTORY_DEF * TeeFactory    FACTORY_NAME Files_To_Load_JSON_VectorSetterUpper    INPUT FEATURE_TYPE Files_To_Load_JSON___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned
# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.
Tcl2 proc Files_To_Load_JSON_f7135709_2456_4b31_af0f_4c816154584d0_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Files_To_Load_JSON___PointCloudThinner    INPUT FEATURE_TYPE Files_To_Load_JSON___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Files_To_Load_JSON_f7135709_2456_4b31_af0f_4c816154584d0_thinPointCloud")
Tcl2 proc Files_To_Load_JSON_f7135709_2456_4b31_af0f_4c816154584d0_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Files_To_Load_JSON_RasterSetterUpper    INPUT FEATURE_TYPE Files_To_Load_JSON___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Files_To_Load_JSON_f7135709_2456_4b31_af0f_4c816154584d0_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Files_To_Load_JSON_f7135709_2456_4b31_af0f_4c816154584d0_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.
DEFAULT_MACRO Files_To_Load_JSON_f7135709_2456_4b31_af0f_4c816154584d0_VIS_FEAT_TYPE Files_To_Load_JSON$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.
FACTORY_DEF * RecorderFactory    FACTORY_NAME Files_To_Load_JSON_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Files_To_Load_JSON_f7135709_2456_4b31_af0f_4c816154584d0_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA table_name,varchar<openparen>255<closeparen>,surveyid,varchar<openparen>255<closeparen>,path_windows,varchar<openparen>255<closeparen>,RecordName,varchar<openparen>255<closeparen>,_list_index,varchar<openparen>255<closeparen>,_is_json,varchar<openparen>255<closeparen>,_qual_tbl_name,varchar<openparen>255<closeparen>    MODE RECORD    STORE_SCANNED_METADATA    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000
# -------------------------------------------------------------------------
FACTORY_DEF {*} AttrSetFactory    COMMAND_PARM_EVALUATION SINGLE_PASS    FACTORY_NAME AttributeManager_5    INPUT  FEATURE_TYPE Tester_5_FAILED_0_UcZc14KBmAs=    MULTI_FEATURE_MODE NO     NULL_ATTR_MODE NO_OP     ATTRSET_CREATE_DIRECTIVES _PROPAGATE_MISSING_FDIV    ACTION_COLUMN 3    DEF_VAL_COLUMN 2    ATTR_ACTION { "path_windows" "_CSV_file_name" "" "RENAME_SET_VALUE" }    OUTPUT OUTPUT FEATURE_TYPE AttributeManager_5_OUTPUT
FACTORY_DEF * TeeFactory   FACTORY_NAME "AttributeManager_5_OUTPUT Feature Counter -1 161"   INPUT FEATURE_TYPE AttributeManager_5_OUTPUT   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 161")
# -------------------------------------------------------------------------
MACRO FeatureReader_2_OUTPUT_PORTS_ENCODED 
MACRO FeatureReader_2_DIRECTIVES _ENCODING utf-8 FILTER_GROUP NO _SORT_TABLE_CONFIG """NOT_OK_IF_INVALID%NO_LABEL%ROW_DELIM:;%COL_DELIM:,%HAS_DEFAULTS%START_NUM_ROWS:3%\""Attribute\""%\""STRING_OR_CHOICE_ENCODED ATTRIBUTES %\""%%\""Alpha/Num\""%\""LOOKUP_CHOICE SORT_CHOICE Alphabetic,alphabetic%Numeric,numeric\""%alphabetic%\""Order\""%\""LOOKUP_CHOICE SORT_ORDER Ascending,ascending%Descending,descending\""%ascending""" _GROUP_BY_DATASET no _FIELD_NAMES_AFTER_HEADER no SCAN_MAX_FEATURES 1000 _IN_FIELD_NAMES YES _IN_SEPARATOR , _STRIP_QUOTES yes _SKIP_FOOTER 0 _SCHEMA_WITH_COL_NAMES name,char,12,,RecordName,char,6,,coltype,char,17, _DUPLICATE_DELIMS no _FILTER_TABLE_CONFIG """NOT_OK_IF_INVALID%NO_LABEL%ROW_DELIM:;%COL_DELIM:,%HAS_DEFAULTS%START_NUM_ROWS:3%\""Field Name\""%\""STRING_OR_CHOICE_ENCODED ATTRIBUTES %\""%%\""Filter\""%\""STRING_ENCODED _FILTER_REGEX \""%%\""Invert Filter\""%\""CHECKBOX _FILTER_UNMATCHED yes%no\""%no""" _SKIP_LINES 1 _SCHEMA char,12,,char,6,,char,17, SORT_GROUP NO
# Values come in encoded and come out decoded.
Tcl2 proc FeatureReader_2_findInListElseDefault { valueEncoded defaultValue } {    if { [lsearch [split {$(FeatureReader_2_OUTPUT_PORTS_ENCODED)}] $valueEncoded] >= 0} {       return FeatureReader_2_[FME_DecodeText $valueEncoded]    } else {       return FeatureReader_2_$defaultValue    } }
# Always provide an INTERACTION, otherwise the factory defaults to ENVELOPE_INTERSECTS
INCLUDE [if { ( {<Unused>} == {<Unused>} ) || ( {($INTERACT_OPTIONS)} == {} ) } {             puts {MACRO FCTQUERY_INTERACTION_LINE FCTQUERY_INTERACTION NONE};          } else {             puts {MACRO FCTQUERY_INTERACTION_LINE FCTQUERY_INTERACTION "<Unused>"};          }         ]
# Consolidate the attribute merge options to what the factory expects
DEFAULT_MACRO FeatureReader_2_COMBINE_ATTRS
INCLUDE [       if { {MERGE} == {MERGE} } {          puts "MACRO FeatureReader_2_COMBINE_ATTRS PREFER_RESULT";       } else {          puts "MACRO FeatureReader_2_COMBINE_ATTRS MERGE";       };    ]
INCLUDE [    puts {DEFAULT_MACRO FeatureReaderDataset_FeatureReader_2 @EvaluateExpression(FDIV,STRING_ENCODED,<at>Value<openparen>_CSV_file_name<closeparen>,FeatureReader_2)}; ]
FACTORY_DEF * QueryFactory    FACTORY_NAME FeatureReader_2    INPUT  FEATURE_TYPE AttributeManager_5_OUTPUT    $(FCTQUERY_INTERACTION_LINE)    QUERYFCT_TABLE_SEPARATOR SPACE    COMBINE_ATTRIBUTES  $(FeatureReader_2_COMBINE_ATTRS)    QUERYFCT_ATTRIBUTE_PREFIX <Unused>    COMBINE_GEOMETRY    RESULT_ONLY    ENABLE_CACHE        NO    READER_TYPE         CSV    READER_DATASET      "$(FeatureReaderDataset_FeatureReader_2)"    READER_IDS    READER_DIRECTIVES   META_MACROS,SourcegroupBox_2<comma><comma>Source_IN_SEPARATOR<comma><quote><comma><quote><comma>Source_DUPLICATE_DELIMS<comma>no<comma>Source_STRIP_QUOTES<comma>yes<comma>Source_IN_FIELD_NAMES<comma>YES<comma>Source_FIELD_NAMES_AFTER_HEADER<comma>no<comma>SourcegroupBox<comma><comma>Source_SKIP_LINES<comma>1<comma>Source_SKIP_FOOTER<comma>0<comma>SourcegroupBox_6<comma><comma>Source_ENCODING<comma>utf-8<comma>Source_ALLOW_SPACES_IN_COLUMN_NAMES<comma>yes<comma>SourcegroupBox_4<comma><comma>Source_GROUP_BY_DATASET<comma>no<comma>SourcegroupBox_5<comma><comma>Source_SCHEMA<comma><quote>char<comma>12<comma><comma>char<comma>6<comma><comma>char<comma>17<comma><quote><comma>Source_SCHEMA_WITH_COL_NAMES<comma><quote>name<comma>char<comma>12<comma><comma>RecordName<comma>char<comma>6<comma><comma>coltype<comma>char<comma>17<comma><quote><comma>SourceSCAN_MAX_FEATURES<comma>1000<comma>SourceSORT_GROUP<comma>NO<comma>SourceFILTER_GROUP<comma>NO<comma>Source_SORT_PARAMS<comma><comma>Source_SORT_TABLE_CONFIG<comma><quote><quote><quote>NOT_OK_IF_INVALID%NO_LABEL%ROW_DELIM:<semicolon>%COL_DELIM:<comma>%HAS_DEFAULTS%START_NUM_ROWS:3%<backslash><quote><quote>Attribute<backslash><quote><quote>%<backslash><quote><quote>STRING_OR_CHOICE_ENCODED<space>ATTRIBUTES<space>%<backslash><quote><quote>%%<backslash><quote><quote>Alpha<solidus>Num<backslash><quote><quote>%<backslash><quote><quote>LOOKUP_CHOICE<space>SORT_CHOICE<space>Alphabetic<comma>alphabetic%Numeric<comma>numeric<backslash><quote><quote>%alphabetic%<backslash><quote><quote>Order<backslash><quote><quote>%<backslash><quote><quote>LOOKUP_CHOICE<space>SORT_ORDER<space>Ascending<comma>ascending%Descending<comma>descending<backslash><quote><quote>%ascending<quote><quote><quote><comma>Source_FILTER_PARAMS<comma><comma>Source_FILTER_TABLE_CONFIG<comma><quote><quote><quote>NOT_OK_IF_INVALID%NO_LABEL%ROW_DELIM:<semicolon>%COL_DELIM:<comma>%HAS_DEFAULTS%START_NUM_ROWS:3%<backslash><quote><quote>Field<space>Name<backslash><quote><quote>%<backslash><quote><quote>STRING_OR_CHOICE_ENCODED<space>ATTRIBUTES<space>%<backslash><quote><quote>%%<backslash><quote><quote>Filter<backslash><quote><quote>%<backslash><quote><quote>STRING_ENCODED<space>_FILTER_REGEX<space><backslash><quote><quote>%%<backslash><quote><quote>Invert<space>Filter<backslash><quote><quote>%<backslash><quote><quote>CHECKBOX<space>_FILTER_UNMATCHED<space>yes%no<backslash><quote><quote>%no<quote><quote><quote>,METAFILE,CSV    QUERYFCT_OUTPUT     "BASED_ON_CONNECTIONS"    CONTINUE_ON_READER_ERROR YES    READER_PARAMS     $(FeatureReader_2_DIRECTIVES)    OUTPUT RESULT FEATURE_TYPE *         @SupplyAttributes(fme_feature_type,@FeatureType())         @Tcl2("set FME_FeatureType [FeatureReader_2_findInListElseDefault [FME_EncodeText $FME_FeatureType] {<OTHER>}]")         @Transform(CSV,FME_GENERIC)    OUTPUT READER_ERROR FEATURE_TYPE FeatureReader_2_<REJECTED>
FACTORY_DEF * RecorderFactory FACTORY_NAME "FeatureReader_2_<REJECTED> Feature Recorder -1 2147811482" INPUT FEATURE_TYPE FeatureReader_2_<REJECTED> FEATURE_FILE "C:/Users/ZOOL13~1.NDP/AppData/Local/Temp/wb-cache-Load_DHS_Data_To_PG_With_Checks-F34608/Main_FeatureReader_2 -1 154 fo 3 _lt_REJECTED_gt_  0  378dd42124509d3b311aa089e96dc4a2ab7f8d86.ffsupdating" MODE RECORD_PASS_THROUGH STORE_SCANNED_SCHEMA YES CREATE_SPATIAL_INDEX YES INSPECTOR YES RECORD_DIRECTLY_TO_DISK YES FSC_SCHEMA _CSV_file_name,varchar<openparen>255<closeparen>,table_name,varchar<openparen>255<closeparen>,surveyid,varchar<openparen>255<closeparen>,RecordName,varchar<openparen>255<closeparen>,attribute<opencurly><closecurly>.fme_data_type,varchar<openparen>255<closeparen>,attribute<opencurly><closecurly>.name,varchar<openparen>255<closeparen>,_is_json,varchar<openparen>255<closeparen>,_list_index,varchar<openparen>255<closeparen>,_qual_tbl_name,varchar<openparen>255<closeparen>,_reader_error,varchar<openparen>255<closeparen> STORE_SCANNED_METADATA PASS_THROUGH_FME_TYPE OUTPUT RECORDED FEATURE_TYPE *
FACTORY_DEF * TeeFactory   FACTORY_NAME "FeatureReader_2_<OTHER> Feature Counter -1 158"   INPUT FEATURE_TYPE FeatureReader_2_<OTHER>   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 158")
FACTORY_DEF * TeeFactory   FACTORY_NAME "FeatureReader_2_<REJECTED> Feature Counter -1 2147811482"   INPUT FEATURE_TYPE FeatureReader_2_<REJECTED>     @LogCount("PORT -1 2147811482")
# -------------------------------------------------------------------------
FACTORY_DEF {*} TeeFactory    FACTORY_NAME BulkAttributeRenamer    INPUT  FEATURE_TYPE FeatureReader_2_<OTHER>    OUTPUT { FEATURE_TYPE BulkAttributeRenamer_OUTPUT        @RenameAttributes(PATTERN_REPLACE, CASECHANGE, <Unused>, "<Unused>", "<Unused>", "lower", "<Unused>", "-_", "RENAME", "NONFME")         }
FACTORY_DEF * TeeFactory   FACTORY_NAME "BulkAttributeRenamer_OUTPUT Feature Counter -1 157"   INPUT FEATURE_TYPE BulkAttributeRenamer_OUTPUT   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 157")
# -------------------------------------------------------------------------
INCLUDE [    set macroLine "MACRO AttributeRemover_LIST_EXP ";    foreach attr [split "attribute<opencurly><closecurly>"] {       set attr [FME_DecodeText $attr];       set attr [regsub "{}$" $attr "{}.*"];       set attr [regsub -all "{}" $attr "\\{\[0-9\]+\\}"];       append macroLine ",^$attr$";    };    puts $macroLine; ]
FACTORY_DEF {*} TeeFactory    FACTORY_NAME AttributeRemover    INPUT  FEATURE_TYPE BulkAttributeRenamer_OUTPUT    OUTPUT { FEATURE_TYPE AttributeRemover_OUTPUT        @RemoveAttributes(fme_encoded,_csv_file_name,fme_basename)        @RemoveAttributes(fme_pcre_match"$(AttributeRemover_LIST_EXP)")         }
FACTORY_DEF * TeeFactory   FACTORY_NAME "AttributeRemover_OUTPUT Feature Counter -1 164"   INPUT FEATURE_TYPE AttributeRemover_OUTPUT   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 164")
# -------------------------------------------------------------------------
FACTORY_DEF * TeeFactory   FACTORY_NAME "AttributeJSONPacker_2 Input Input Collector"   INPUT FEATURE_TYPE AttributeRemover_OUTPUT   OUTPUT FEATURE_TYPE AttributeJSONPacker_2_Input
MACRO AttributeJSONPacker_WORKSPACE_NAME AttributeJSONPacker_2
MACRO $(AttributeJSONPacker_WORKSPACE_NAME)_XFORMER_NAME AttributeJSONPacker_2
MACRO $(AttributeJSONPacker_WORKSPACE_NAME)_TRANSFORMER_GROUP 
MACRO $(AttributeJSONPacker_WORKSPACE_NAME)___COMPOUND_PARAMETERS 
MACRO $(AttributeJSONPacker_WORKSPACE_NAME)_SUB_DOC_NAME AttributeJSONPacker
MACRO $(AttributeJSONPacker_WORKSPACE_NAME)_FILTER 
MACRO $(AttributeJSONPacker_WORKSPACE_NAME)_PACKED data
MACRO $(AttributeJSONPacker_WORKSPACE_NAME)_ATTRS 
MACRO $(AttributeJSONPacker_WORKSPACE_NAME)_SKIPATTRS squestid,table_name,hhid,caseid,ixh4,recordname,_list_index,surveyid,_is_json,_qual_tbl_name
MACRO $(AttributeJSONPacker_WORKSPACE_NAME)_FILTEREXC idx
DEFAULT_MACRO AttributeJSONPacker_WORKSPACE_NAME ""
INCLUDE [puts {MACRO WB_OLD_CONTEXT_$(AttributeJSONPacker_WORKSPACE_NAME) $(WB_CURRENT_CONTEXT)};          puts {MACRO WB_CURRENT_CONTEXT $(AttributeJSONPacker_WORKSPACE_NAME)}]
FACTORY_DEF * TeeFactory   FACTORY_NAME "$(AttributeJSONPacker_WORKSPACE_NAME)_Input1557829063 Input Splitter"   INPUT FEATURE_TYPE "$(AttributeJSONPacker_WORKSPACE_NAME)_Input"   OUTPUT FEATURE_TYPE "$(AttributeJSONPacker_WORKSPACE_NAME)_Input"
FACTORY_DEF * TeeFactory   FACTORY_NAME "$(AttributeJSONPacker_WORKSPACE_NAME)_Input Feature Counter 0 6"   INPUT FEATURE_TYPE "$(AttributeJSONPacker_WORKSPACE_NAME)_Input"   OUTPUT FEATURE_TYPE *     @LogCount("LINK 0 6")
# -------------------------------------------------------------------------
Tcl2 proc $(AttributeJSONPacker_WORKSPACE_NAME)_ParameterFetcher_doFetch {} {    foreach {name val} {"AttributeJSONPacker_FILTER {$($(AttributeJSONPacker_WORKSPACE_NAME)_FILTER$encode)} AttributeJSONPacker_PACKED {$($(AttributeJSONPacker_WORKSPACE_NAME)_PACKED$encode)} AttributeJSONPacker_ATTRS {$($(AttributeJSONPacker_WORKSPACE_NAME)_ATTRS$encode)} AttributeJSONPacker_SKIPATTRS {$($(AttributeJSONPacker_WORKSPACE_NAME)_SKIPATTRS$encode)} AttributeJSONPacker_FILTEREXC {$($(AttributeJSONPacker_WORKSPACE_NAME)_FILTEREXC$encode)}"} {         if { [string match {*<at>*} $val] == 1 } {             set val [FME_Execute EvaluateExpression {STRING} $val {$(AttributeJSONPacker_WORKSPACE_NAME)_ParameterFetcher}];         } elseif {[string match {*FME_CONDITIONAL*} $val] == 1} {             set val [FME_Execute EvaluateExpression {STRING} $val {$(AttributeJSONPacker_WORKSPACE_NAME)_ParameterFetcher}];         } else {             set val [FME_DecodeTextOrAttr $val];         };       FME_SetAttribute [FME_DecodeText $name] $val    } }
FACTORY_DEF * TeeFactory    FACTORY_NAME $(AttributeJSONPacker_WORKSPACE_NAME)_ParameterFetcher    INPUT  FEATURE_TYPE "$(AttributeJSONPacker_WORKSPACE_NAME)_Input"    OUTPUT FEATURE_TYPE "$(AttributeJSONPacker_WORKSPACE_NAME)_ParameterFetcher_OUTPUT"         @Tcl2($(AttributeJSONPacker_WORKSPACE_NAME)_ParameterFetcher_doFetch)
FACTORY_DEF * TeeFactory   FACTORY_NAME "$(AttributeJSONPacker_WORKSPACE_NAME)_ParameterFetcher_OUTPUT Feature Counter 0 8"   INPUT FEATURE_TYPE "$(AttributeJSONPacker_WORKSPACE_NAME)_ParameterFetcher_OUTPUT"   OUTPUT FEATURE_TYPE *     @LogCount("LINK 0 8")
# -------------------------------------------------------------------------
FME_PYTHON_PATH "$(FME_MF_DIR)"
FACTORY_DEF * PythonFactory    FACTORY_NAME $(AttributeJSONPacker_WORKSPACE_NAME)_PythonCaller    INPUT  FEATURE_TYPE "$(AttributeJSONPacker_WORKSPACE_NAME)_ParameterFetcher_OUTPUT"    SYMBOL_NAME packIgdsAtts    PYTHON_NAMESPACE FMEOBJECTS    SOURCE_CODE import<space>fmeobjects<lf>import<space>binascii<lf>import<space>json<lf><lf>#<space>This<space>class<space>will<space>create<space>a<space>packed<space>list<space>of<space>format<lf>#<space>attributes<space>suitable<space>for<space>use<space>with<space><at>SupplyAttributes<openparen><closeparen><lf><lf>def<space>packIgdsAtts<openparen>feature<closeparen>:<lf><space><space><space><lf><space><space><space>#<space>get<space>a<space>list<space>of<space>attribute<space>names<lf><space><space><space>attlist<space>=<space>feature.getAllAttributeNames<openparen><closeparen><lf><space><space><space>attlist<space>=<space>map<openparen>unicode<comma><space>attlist<closeparen><lf><space><space><space><lf><space><space><space>#<space>get<space>attributes<space>to<space>pack<lf><space><space><space>pack_attrs<space>=<space>feature.getAttribute<openparen><apos>AttributeJSONPacker_ATTRS<apos><closeparen>.replace<openparen><apos><quote><apos><comma><space><apos><apos><closeparen>.strip<openparen><closeparen>.split<openparen><apos><comma><apos><closeparen><lf><space><space><space><lf><space><space><space>skip_attrs<space>=<space>feature.getAttribute<openparen><apos>AttributeJSONPacker_SKIPATTRS<apos><closeparen>.replace<openparen><apos><quote><apos><comma><space><apos><apos><closeparen>.strip<openparen><closeparen>.split<openparen><apos><comma><apos><closeparen><lf><space><space><space><lf><space><space><space>#<space>get<space>filter<space>value<lf><space><space><space>filter<space>=<space>feature.getAttribute<openparen><apos>AttributeJSONPacker_FILTER<apos><closeparen><lf><space><space><space>filterExc<space>=<space>feature.getAttribute<openparen><apos>AttributeJSONPacker_FILTEREXC<apos><closeparen><lf><space><space><space><lf><space><space><space>#<space>get<space>packed<space>attribute<space>name<lf><space><space><space>packedAtt<space>=<space>feature.getAttribute<openparen><apos>AttributeJSONPacker_PACKED<apos><closeparen><lf><space><space><space><lf><space><space><space>#<space>disable<space>filter<space>if<space>packed<space>attribute<space>chosen<lf><space><space><space>if<space>pack_attrs<openbracket>0<closebracket><space>!=<space><quote><quote>:<lf><space><space><space><space><space><space><space>filter<space>=<space><apos>########################################################################<apos><lf><space><space><space><space><space><space><space><lf><space><space><space>#<space>create<space>list<space>for<space>packed<space>attributes<lf><space><space><space>packed<space>=<space><opencurly><closecurly><lf><space><space><space><lf><space><space><space>#<space>loop<space>through<space>attribute<space>names<lf><space><space><space>for<space>att<space>in<space>attlist:<lf><space><space><space><space><space><space><space>if<space><openparen><openparen>filter<space>in<space>att<space>or<space>att<space>in<space>pack_attrs<closeparen><space>and<space><openparen>not<space>att<space>in<space>skip_attrs<closeparen><space>and<space><lf><space><space><space><space><space><space><space><space><space><space><space><space><openparen>not<space>filterExc<space>in<space>att<closeparen><space>and<lf><space><space><space><space><space><space><space><space><space><space><space><space>att<space>!=<space><apos>AttributeJSONPacker_ATTRS<apos><space>and<space><lf><space><space><space><space><space><space><space><space><space><space><space><space>att<space>!=<space><apos>AttributeJSONPacker_FILTER<apos><space>and<space><lf><space><space><space><space><space><space><space><space><space><space><space><space>att<space>!=<space><apos>AttributeJSONPacker_PACKED<apos><space>and<space><lf><space><space><space><space><space><space><space><space><space><space><space><space>att<space>!=<space><apos>AttributeJSONPacker_SKIPATTRS<apos><space>and<space><lf><space><space><space><space><space><space><space><space><space><space><space><space>att<space>!=<space><apos>AttributeJSONPacker_FILTEREXC<apos><space>and<lf><space><space><space><space><space><space><space><space><space><space><space><space>not<space>att.startswith<openparen><apos>fme<apos><closeparen><space>and<space><lf><space><space><space><space><space><space><space><space><space><space><space><space>not<space>att.startswith<openparen><apos>csv<apos><closeparen><closeparen>:<lf><space><space><space><space><space><space><space><space><space><space><space>att_value<space>=<space>feature.getAttribute<openparen>att<closeparen><lf><space><space><space><space><space><space><space><space><space><space><space>#<space>convert<space>binary<space>attributes<space>to<space>hex<space>for<space>storage<lf><space><space><space><space><space><space><space><space><space><space><space>if<space>type<openparen>att_value<closeparen><space>==<space>bytearray:<lf><space><space><space><space><space><space><space><space><space><space><space><space><space><space><space>att_value<space>=<space><quote>0x<quote><space>+<space>binascii.hexlify<openparen>att_value<closeparen><lf><space><space><space><space><space><space><space><space><space><space><space>#<space>append<space>attribute<space>value<lf><space><space><space><space><space><space><space><space><space><space><space>packed<openbracket>att<closebracket><space>=<space>att_value<lf><space><space><space><lf><space><space><space>#add<space>packed<space>attributes<space>in<space>JSON<space>format<lf><space><space><space>feature.setAttribute<openparen>packedAtt<comma>json.dumps<openparen>packed<comma>separators=<openparen><apos><comma><apos><comma><space><apos>:<apos><closeparen><comma><space>ensure_ascii=False<closeparen><closeparen>    OUTPUT PYOUTPUT FEATURE_TYPE "$(AttributeJSONPacker_WORKSPACE_NAME)_PythonCaller_OUTPUT"
FACTORY_DEF * TeeFactory   FACTORY_NAME "$(AttributeJSONPacker_WORKSPACE_NAME)_PythonCaller_OUTPUT Feature Counter 0 7"   INPUT FEATURE_TYPE "$(AttributeJSONPacker_WORKSPACE_NAME)_PythonCaller_OUTPUT"   OUTPUT FEATURE_TYPE *     @LogCount("LINK 0 7")
FACTORY_DEF * TeeFactory   FACTORY_NAME "$(AttributeJSONPacker_WORKSPACE_NAME)_Output1557829063 Output Collector"   INPUT FEATURE_TYPE "$(AttributeJSONPacker_WORKSPACE_NAME)_PythonCaller_OUTPUT"   OUTPUT FEATURE_TYPE "$(AttributeJSONPacker_WORKSPACE_NAME)_Output" @RemoveAttributes(AttributeJSONPacker_FILTER,AttributeJSONPacker_PACKED,AttributeJSONPacker_ATTRS,AttributeJSONPacker_SKIPATTRS,AttributeJSONPacker_FILTEREXC)
INCLUDE [puts {MACRO WB_CURRENT_CONTEXT $(WB_OLD_CONTEXT_$(AttributeJSONPacker_WORKSPACE_NAME))}]
FACTORY_DEF * TeeFactory   FACTORY_NAME "AttributeJSONPacker_2 Output Output Renamer/Nuker"   INPUT FEATURE_TYPE AttributeJSONPacker_2_Output   OUTPUT FEATURE_TYPE AttributeJSONPacker_2_Output
FACTORY_DEF * TeeFactory   FACTORY_NAME "AttributeJSONPacker_2_Output Feature Counter -1 150"   INPUT FEATURE_TYPE AttributeJSONPacker_2_Output   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 150")
# -------------------------------------------------------------------------
# Expose all attributes.  This ensures that if you expose fme_dataset, you will get it.
READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
FACTORY_DEF * TeeFactory    FACTORY_NAME AttributeExposer    INPUT  FEATURE_TYPE AttributeJSONPacker_2_Output    OUTPUT FEATURE_TYPE AttributeExposer_OUTPUT
FACTORY_DEF * TeeFactory   FACTORY_NAME "AttributeExposer_OUTPUT Feature Counter -1 171"   INPUT FEATURE_TYPE AttributeExposer_OUTPUT   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 171")
# -------------------------------------------------------------------------
# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.
READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Files_To_Load_Normal} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Files_To_Load_Normal_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Files_To_Load_Normal_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing
FACTORY_DEF * TestFactory    FACTORY_NAME Files_To_Load_Normal_FeatureDirector    INPUT  FEATURE_TYPE Tester_5_PASSED_1_hayxW2aoLHY=    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Files_To_Load_Normal___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Files_To_Load_Normal___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Files_To_Load_Normal___FeatureDirector1    INPUT FEATURE_TYPE Files_To_Load_Normal___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Files_To_Load_Normal___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Files_To_Load_Normal___PointCloudFeatures___
# Vector features simply may get their colors overridden
FACTORY_DEF * TeeFactory    FACTORY_NAME Files_To_Load_Normal_VectorSetterUpper    INPUT FEATURE_TYPE Files_To_Load_Normal___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned
# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.
Tcl2 proc Files_To_Load_Normal_9c9a79cd_07e6_44d3_b8ad_2099c93ae2b90_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Files_To_Load_Normal___PointCloudThinner    INPUT FEATURE_TYPE Files_To_Load_Normal___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Files_To_Load_Normal_9c9a79cd_07e6_44d3_b8ad_2099c93ae2b90_thinPointCloud")
Tcl2 proc Files_To_Load_Normal_9c9a79cd_07e6_44d3_b8ad_2099c93ae2b90_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Files_To_Load_Normal_RasterSetterUpper    INPUT FEATURE_TYPE Files_To_Load_Normal___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Files_To_Load_Normal_9c9a79cd_07e6_44d3_b8ad_2099c93ae2b90_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Files_To_Load_Normal_9c9a79cd_07e6_44d3_b8ad_2099c93ae2b90_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.
DEFAULT_MACRO Files_To_Load_Normal_9c9a79cd_07e6_44d3_b8ad_2099c93ae2b90_VIS_FEAT_TYPE Files_To_Load_Normal$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.
FACTORY_DEF * RecorderFactory    FACTORY_NAME Files_To_Load_Normal_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Files_To_Load_Normal_9c9a79cd_07e6_44d3_b8ad_2099c93ae2b90_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA table_name,varchar<openparen>255<closeparen>,surveyid,varchar<openparen>255<closeparen>,path_windows,varchar<openparen>255<closeparen>,RecordName,varchar<openparen>255<closeparen>,_list_index,varchar<openparen>255<closeparen>,_is_json,varchar<openparen>255<closeparen>,_qual_tbl_name,varchar<openparen>255<closeparen>    MODE RECORD    STORE_SCANNED_METADATA    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000
# -------------------------------------------------------------------------
MACRO FeatureReader_OUTPUT_PORTS_ENCODED 
MACRO FeatureReader_DIRECTIVES _FILTER_TABLE_CONFIG """NOT_OK_IF_INVALID%NO_LABEL%ROW_DELIM:;%COL_DELIM:,%HAS_DEFAULTS%START_NUM_ROWS:3%\""Field Name\""%\""STRING_OR_CHOICE_ENCODED ATTRIBUTES %\""%%\""Filter\""%\""STRING_ENCODED _FILTER_REGEX \""%%\""Invert Filter\""%\""CHECKBOX _FILTER_UNMATCHED yes%no\""%no""" _SCHEMA char,12,,char,6,,char,17, _ALLOW_SPACES_IN_COLUMN_NAMES yes SORT_GROUP NO _STRIP_QUOTES yes _SKIP_FOOTER 0 _SCHEMA_WITH_COL_NAMES name,char,12,,RecordName,char,6,,coltype,char,17, _FIELD_NAMES_AFTER_HEADER no _DUPLICATE_DELIMS no _IN_FIELD_NAMES YES SCAN_MAX_FEATURES 1000 _SORT_TABLE_CONFIG """NOT_OK_IF_INVALID%NO_LABEL%ROW_DELIM:;%COL_DELIM:,%HAS_DEFAULTS%START_NUM_ROWS:3%\""Attribute\""%\""STRING_OR_CHOICE_ENCODED ATTRIBUTES %\""%%\""Alpha/Num\""%\""LOOKUP_CHOICE SORT_CHOICE Alphabetic,alphabetic%Numeric,numeric\""%alphabetic%\""Order\""%\""LOOKUP_CHOICE SORT_ORDER Ascending,ascending%Descending,descending\""%ascending""" FILTER_GROUP NO _IN_SEPARATOR , _SKIP_LINES 1 _GROUP_BY_DATASET no
# Values come in encoded and come out decoded.
Tcl2 proc FeatureReader_findInListElseDefault { valueEncoded defaultValue } {    if { [lsearch [split {$(FeatureReader_OUTPUT_PORTS_ENCODED)}] $valueEncoded] >= 0} {       return FeatureReader_[FME_DecodeText $valueEncoded]    } else {       return FeatureReader_$defaultValue    } }
# Always provide an INTERACTION, otherwise the factory defaults to ENVELOPE_INTERSECTS
INCLUDE [if { ( {<Unused>} == {<Unused>} ) || ( {($INTERACT_OPTIONS)} == {} ) } {             puts {MACRO FCTQUERY_INTERACTION_LINE FCTQUERY_INTERACTION NONE};          } else {             puts {MACRO FCTQUERY_INTERACTION_LINE FCTQUERY_INTERACTION "<Unused>"};          }         ]
# Consolidate the attribute merge options to what the factory expects
DEFAULT_MACRO FeatureReader_COMBINE_ATTRS
INCLUDE [       if { {MERGE} == {MERGE} } {          puts "MACRO FeatureReader_COMBINE_ATTRS PREFER_RESULT";       } else {          puts "MACRO FeatureReader_COMBINE_ATTRS MERGE";       };    ]
INCLUDE [    puts {DEFAULT_MACRO FeatureReaderDataset_FeatureReader @EvaluateExpression(FDIV,STRING_ENCODED,<at>Value<openparen>path_windows<closeparen>,FeatureReader)}; ]
FACTORY_DEF * QueryFactory    FACTORY_NAME FeatureReader    INPUT  FEATURE_TYPE Tester_5_PASSED_0_OWdaF3NzV3Q=    $(FCTQUERY_INTERACTION_LINE)    QUERYFCT_TABLE_SEPARATOR SPACE    COMBINE_ATTRIBUTES  $(FeatureReader_COMBINE_ATTRS)    QUERYFCT_ATTRIBUTE_PREFIX <Unused>    COMBINE_GEOMETRY    RESULT_ONLY    ENABLE_CACHE        NO    READER_TYPE         CSV    READER_DATASET      "$(FeatureReaderDataset_FeatureReader)"    READER_IDS    READER_DIRECTIVES   META_MACROS,SourcegroupBox_4<comma><comma>SourcegroupBox_2<comma><comma>Source_FILTER_TABLE_CONFIG<comma><quote><quote><quote>NOT_OK_IF_INVALID%NO_LABEL%ROW_DELIM:<semicolon>%COL_DELIM:<comma>%HAS_DEFAULTS%START_NUM_ROWS:3%<backslash><quote><quote>Field<space>Name<backslash><quote><quote>%<backslash><quote><quote>STRING_OR_CHOICE_ENCODED<space>ATTRIBUTES<space>%<backslash><quote><quote>%%<backslash><quote><quote>Filter<backslash><quote><quote>%<backslash><quote><quote>STRING_ENCODED<space>_FILTER_REGEX<space><backslash><quote><quote>%%<backslash><quote><quote>Invert<space>Filter<backslash><quote><quote>%<backslash><quote><quote>CHECKBOX<space>_FILTER_UNMATCHED<space>yes%no<backslash><quote><quote>%no<quote><quote><quote><comma>Source_SCHEMA<comma><quote>char<comma>12<comma><comma>char<comma>6<comma><comma>char<comma>17<comma><quote><comma>Source_ALLOW_SPACES_IN_COLUMN_NAMES<comma>yes<comma>SourceSORT_GROUP<comma>NO<comma>Source_STRIP_QUOTES<comma>yes<comma>Source_SKIP_FOOTER<comma>0<comma>Source_SCHEMA_WITH_COL_NAMES<comma><quote>name<comma>char<comma>12<comma><comma>RecordName<comma>char<comma>6<comma><comma>coltype<comma>char<comma>17<comma><quote><comma>Source_FIELD_NAMES_AFTER_HEADER<comma>no<comma>SourcegroupBox_6<comma><comma>Source_DUPLICATE_DELIMS<comma>no<comma>Source_IN_FIELD_NAMES<comma>YES<comma>SourceSCAN_MAX_FEATURES<comma>1000<comma>Source_ENCODING<comma><comma>Source_SORT_TABLE_CONFIG<comma><quote><quote><quote>NOT_OK_IF_INVALID%NO_LABEL%ROW_DELIM:<semicolon>%COL_DELIM:<comma>%HAS_DEFAULTS%START_NUM_ROWS:3%<backslash><quote><quote>Attribute<backslash><quote><quote>%<backslash><quote><quote>STRING_OR_CHOICE_ENCODED<space>ATTRIBUTES<space>%<backslash><quote><quote>%%<backslash><quote><quote>Alpha<solidus>Num<backslash><quote><quote>%<backslash><quote><quote>LOOKUP_CHOICE<space>SORT_CHOICE<space>Alphabetic<comma>alphabetic%Numeric<comma>numeric<backslash><quote><quote>%alphabetic%<backslash><quote><quote>Order<backslash><quote><quote>%<backslash><quote><quote>LOOKUP_CHOICE<space>SORT_ORDER<space>Ascending<comma>ascending%Descending<comma>descending<backslash><quote><quote>%ascending<quote><quote><quote><comma>SourceFILTER_GROUP<comma>NO<comma>Source_IN_SEPARATOR<comma><quote><comma><quote><comma>Source_SKIP_LINES<comma>1<comma>SourcegroupBox_5<comma><comma>SourcegroupBox<comma><comma>Source_GROUP_BY_DATASET<comma>no<comma>SourceSTRIP_QUOTES<comma>yes<comma>SourceDUPLICATE_DELIMS<comma>no<comma>SourceFIELD_NAMES<comma>YES<comma>SourceSKIP_LINES<comma>1,METAFILE,CSV    QUERYFCT_OUTPUT     "BASED_ON_CONNECTIONS"    CONTINUE_ON_READER_ERROR YES    READER_PARAMS     $(FeatureReader_DIRECTIVES)    OUTPUT RESULT FEATURE_TYPE *         @SupplyAttributes(fme_feature_type,@FeatureType())         @Tcl2("set FME_FeatureType [FeatureReader_findInListElseDefault [FME_EncodeText $FME_FeatureType] {<OTHER>}]")         @Transform(CSV,FME_GENERIC)    OUTPUT READER_ERROR FEATURE_TYPE FeatureReader_<REJECTED>
FACTORY_DEF * RecorderFactory FACTORY_NAME "FeatureReader_<REJECTED> Feature Recorder -1 2147811353" INPUT FEATURE_TYPE FeatureReader_<REJECTED> FEATURE_FILE "C:/Users/ZOOL13~1.NDP/AppData/Local/Temp/wb-cache-Load_DHS_Data_To_PG_With_Checks-F34608/Main_FeatureReader -1 25 fo 3 _lt_REJECTED_gt_  0  7cfd41291fe4b4c63332437f4799d36cf7faf0c1.ffsupdating" MODE RECORD_PASS_THROUGH STORE_SCANNED_SCHEMA YES CREATE_SPATIAL_INDEX YES INSPECTOR YES RECORD_DIRECTLY_TO_DISK YES FSC_SCHEMA table_name,varchar<openparen>255<closeparen>,surveyid,varchar<openparen>255<closeparen>,path_windows,varchar<openparen>255<closeparen>,RecordName,varchar<openparen>255<closeparen>,attribute<opencurly><closecurly>.fme_data_type,varchar<openparen>255<closeparen>,attribute<opencurly><closecurly>.name,varchar<openparen>255<closeparen>,_list_index,varchar<openparen>255<closeparen>,_is_json,varchar<openparen>255<closeparen>,_qual_tbl_name,varchar<openparen>255<closeparen>,_reader_error,varchar<openparen>255<closeparen> STORE_SCANNED_METADATA PASS_THROUGH_FME_TYPE OUTPUT RECORDED FEATURE_TYPE *
FACTORY_DEF * TeeFactory   FACTORY_NAME "FeatureReader_<OTHER> Feature Counter -1 77"   INPUT FEATURE_TYPE FeatureReader_<OTHER>   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 77")
FACTORY_DEF * TeeFactory   FACTORY_NAME "FeatureReader_<REJECTED> Feature Counter -1 2147811353"   INPUT FEATURE_TYPE FeatureReader_<REJECTED>     @LogCount("PORT -1 2147811353")
# -------------------------------------------------------------------------
Tcl2 proc NullAttributeMapper_1beb8ba5_89ba_4f7d_9b2f_c2fdc5703d280_null_replacer { otherValue newValue regExp } {    set attrs [split {<Unused>} { }];    set decode true;    if { {ALL} == {ALL} } {       set attrs [FME_AttributeNames];       set decode false; 	 };    set decodedVal [FME_DecodeText $otherValue];    set decodedRegExp [FME_DecodeText $regExp];    foreach attr $attrs {      set act {NOOP};      if {$decode} {        set attr [FME_DecodeText $attr];      };      if {[FME_AttributeExists $attr]} {          set attrVal [FME_GetAttribute $attr];          if {[FME_IsAttributeNull $attr] } {             if {[string first {SETNULL} {SETNULL EMPTY}] != -1} {                 set act {SETNULL};             };          }          elseif { [string first {EMPTY} {SETNULL EMPTY}] != -1 && $attrVal == {}} {             set act {SETNULL};          }          elseif { $otherValue != {} && [string equal $attrVal $decodedVal]} {             set act {SETNULL};          }          elseif { $decodedRegExp != {} && [regexp $decodedRegExp $attrVal]==1 }          {             set act {SETNULL};          };      }      elseif {[string first {MISSINGATTR} {SETNULL EMPTY}] != -1} {             set act {SETNULL};      };      if {$act == {DELETEATTR} } {         FME_UnsetAttributes $attr;      } elseif { $act == {SETVALUE} } {         FME_SetAttribute $attr [FME_DecodeText $newValue];      } elseif { $act == {SETNULL} } {         FME_SetAttributeNull $attr;      } elseif { $act == {EMPTY} }      {         FME_SetAttribute $attr {};      };   }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME NullAttributeMapper    INPUT  FEATURE_TYPE FeatureReader_<OTHER>    OUTPUT FEATURE_TYPE NullAttributeMapper_OUTPUT         @Tcl2("NullAttributeMapper_1beb8ba5_89ba_4f7d_9b2f_c2fdc5703d280_null_replacer {} {<Unused>} {}")
FACTORY_DEF * TeeFactory   FACTORY_NAME "NullAttributeMapper_OUTPUT Feature Counter -1 178"   INPUT FEATURE_TYPE NullAttributeMapper_OUTPUT   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 178")
# -------------------------------------------------------------------------
FACTORY_DEF {*} TeeFactory    FACTORY_NAME BulkAttributeRenamer_2    INPUT  FEATURE_TYPE NullAttributeMapper_OUTPUT    OUTPUT { FEATURE_TYPE BulkAttributeRenamer_2_OUTPUT        @RenameAttributes(PATTERN_REPLACE, CASECHANGE, <Unused>, "<Unused>", "<Unused>", "lower", "<Unused>", "-_", "RENAME", "NONFME")         }
FACTORY_DEF * TeeFactory   FACTORY_NAME "BulkAttributeRenamer_2_OUTPUT Feature Counter -1 60"   INPUT FEATURE_TYPE BulkAttributeRenamer_2_OUTPUT   OUTPUT FEATURE_TYPE *     @LogCount("LINK -1 60")
# -------------------------------------------------------------------------
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Table_Needs_Reloading_Due_To_Extra_Cols} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Table_Needs_Reloading_Due_To_Extra_Cols_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Table_Needs_Reloading_Due_To_Extra_Cols_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing
FACTORY_DEF * TestFactory    FACTORY_NAME Table_Needs_Reloading_Due_To_Extra_Cols_FeatureDirector    INPUT  FEATURE_TYPE FeatureMerger_4_MERGED_0_MPdsV4kZqGg=    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Table_Needs_Reloading_Due_To_Extra_Cols___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Table_Needs_Reloading_Due_To_Extra_Cols___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Table_Needs_Reloading_Due_To_Extra_Cols___FeatureDirector1    INPUT FEATURE_TYPE Table_Needs_Reloading_Due_To_Extra_Cols___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Table_Needs_Reloading_Due_To_Extra_Cols___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Table_Needs_Reloading_Due_To_Extra_Cols___PointCloudFeatures___
# Vector features simply may get their colors overridden
FACTORY_DEF * TeeFactory    FACTORY_NAME Table_Needs_Reloading_Due_To_Extra_Cols_VectorSetterUpper    INPUT FEATURE_TYPE Table_Needs_Reloading_Due_To_Extra_Cols___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned
# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.
Tcl2 proc Table_Needs_Reloading_Due_To_Extra_Cols_7305c796_f85d_40fd_a623_268f311df5e00_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Table_Needs_Reloading_Due_To_Extra_Cols___PointCloudThinner    INPUT FEATURE_TYPE Table_Needs_Reloading_Due_To_Extra_Cols___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Table_Needs_Reloading_Due_To_Extra_Cols_7305c796_f85d_40fd_a623_268f311df5e00_thinPointCloud")
Tcl2 proc Table_Needs_Reloading_Due_To_Extra_Cols_7305c796_f85d_40fd_a623_268f311df5e00_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Table_Needs_Reloading_Due_To_Extra_Cols_RasterSetterUpper    INPUT FEATURE_TYPE Table_Needs_Reloading_Due_To_Extra_Cols___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Table_Needs_Reloading_Due_To_Extra_Cols_7305c796_f85d_40fd_a623_268f311df5e00_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Table_Needs_Reloading_Due_To_Extra_Cols_7305c796_f85d_40fd_a623_268f311df5e00_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.
DEFAULT_MACRO Table_Needs_Reloading_Due_To_Extra_Cols_7305c796_f85d_40fd_a623_268f311df5e00_VIS_FEAT_TYPE Table_Needs_Reloading_Due_To_Extra_Cols$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.
FACTORY_DEF * RecorderFactory    FACTORY_NAME Table_Needs_Reloading_Due_To_Extra_Cols_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Table_Needs_Reloading_Due_To_Extra_Cols_7305c796_f85d_40fd_a623_268f311df5e00_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    STORE_SCANNED_SCHEMA YES    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA path_unix,varchar<openparen>255<closeparen>,path_windows,varchar<openparen>255<closeparen>,path_rootname,varchar<openparen>255<closeparen>,path_filename,varchar<openparen>255<closeparen>,path_extension,varchar<openparen>255<closeparen>,path_filesize,varchar<openparen>255<closeparen>,path_ownername,varchar<openparen>255<closeparen>,path_readonly,varchar<openparen>255<closeparen>,path_modified_date,varchar<openparen>255<closeparen>,path_created_date,varchar<openparen>255<closeparen>,path_accessed_date,varchar<openparen>255<closeparen>,path_directory_unix,varchar<openparen>255<closeparen>,path_directory_windows,varchar<openparen>255<closeparen>,path_type,varchar<openparen>255<closeparen>,SurveyID_File,varchar<openparen>255<closeparen>,RecordName_File,varchar<openparen>255<closeparen>,_match_id,varchar<openparen>255<closeparen>,table_name,varchar<openparen>255<closeparen>,surveyid,varchar<openparen>255<closeparen>,nrows_db,varchar<openparen>255<closeparen>,nrows_file,varchar<openparen>255<closeparen>,maxlen,varchar<openparen>255<closeparen>,name,varchar<openparen>255<closeparen>,recordname,varchar<openparen>255<closeparen>    MODE RECORD    STORE_SCANNED_METADATA    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000
# -------------------------------------------------------------------------
# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.
READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Files_To_Check} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Files_To_Check_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Files_To_Check_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing
FACTORY_DEF * TestFactory    FACTORY_NAME Files_To_Check_FeatureDirector    INPUT  FEATURE_TYPE Matcher_NOT_MATCHED_0_CJhMt99ptPY=    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Files_To_Check___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Files_To_Check___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Files_To_Check___FeatureDirector1    INPUT FEATURE_TYPE Files_To_Check___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Files_To_Check___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Files_To_Check___PointCloudFeatures___
# Vector features simply may get their colors overridden
FACTORY_DEF * TeeFactory    FACTORY_NAME Files_To_Check_VectorSetterUpper    INPUT FEATURE_TYPE Files_To_Check___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned
# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.
Tcl2 proc Files_To_Check_cb00132b_1e8f_4a41_bdb7_36d2d14db1f90_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Files_To_Check___PointCloudThinner    INPUT FEATURE_TYPE Files_To_Check___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Files_To_Check_cb00132b_1e8f_4a41_bdb7_36d2d14db1f90_thinPointCloud")
Tcl2 proc Files_To_Check_cb00132b_1e8f_4a41_bdb7_36d2d14db1f90_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Files_To_Check_RasterSetterUpper    INPUT FEATURE_TYPE Files_To_Check___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Files_To_Check_cb00132b_1e8f_4a41_bdb7_36d2d14db1f90_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Files_To_Check_cb00132b_1e8f_4a41_bdb7_36d2d14db1f90_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.
DEFAULT_MACRO Files_To_Check_cb00132b_1e8f_4a41_bdb7_36d2d14db1f90_VIS_FEAT_TYPE Files_To_Check$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.
FACTORY_DEF * RecorderFactory    FACTORY_NAME Files_To_Check_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Files_To_Check_cb00132b_1e8f_4a41_bdb7_36d2d14db1f90_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA path_unix,varchar<openparen>255<closeparen>,path_windows,varchar<openparen>255<closeparen>,path_rootname,varchar<openparen>255<closeparen>,path_filename,varchar<openparen>255<closeparen>,path_extension,varchar<openparen>255<closeparen>,path_filesize,varchar<openparen>255<closeparen>,path_ownername,varchar<openparen>255<closeparen>,path_readonly,varchar<openparen>255<closeparen>,path_modified_date,varchar<openparen>255<closeparen>,path_created_date,varchar<openparen>255<closeparen>,path_accessed_date,varchar<openparen>255<closeparen>,path_directory_unix,varchar<openparen>255<closeparen>,path_directory_windows,varchar<openparen>255<closeparen>,path_type,varchar<openparen>255<closeparen>,SurveyID_File,varchar<openparen>255<closeparen>,RecordName_File,varchar<openparen>255<closeparen>,_match_id,varchar<openparen>255<closeparen>    MODE RECORD    STORE_SCANNED_METADATA    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000
# -------------------------------------------------------------------------
# Set the directive to add all the meta-attributes to the features.
# We do this so users see all possible information in the viewed
# features.
READER_META_ATTRIBUTES fme_feature_type fme_dataset fme_basename
# Assumption is that the workspace temp dir has been already set and created.  See controldefs.cpp - ControlDefs::writeVisualizerTempDir
DEFAULT_MACRO WORKSPACE_TEMP_DIR
INCLUDE [         set grpByAttrs {};         if { [string length $grpByAttrs] > 0 } {             if { [string first "@EvaluateExpression" $grpByAttrs] == 0 } {                 puts "MACRO CATMAC _$grpByAttrs" ;             } else {                set catter "" ;                set comma "" ;                foreach attr $grpByAttrs {                    set catter "$catter$comma@Value(\"$attr\")" ;                    set comma ",_," ;                } ;                puts "MACRO CATMAC _@Concatenate($catter)" ;             }         }         else {             puts "MACRO CATMAC " ;         };         set safeName "[regsub -all {[^a-zA-Z0-9]} {Duplicate_Tbl_File_Skipped} _]_[expr round(rand() * 1000000)]_[clock clicks  -milliseconds]";         puts "MACRO SAFE_FFS_NAME $safeName";         ]
# Make the temporary directory that the FFS files will live in.
FACTORY_DEF * CreationFactory      FACTORY_NAME Duplicate_Tbl_File_Skipped_DirCreator      OUTPUT FEATURE_TYPE __nukeme__          @Tcl2("catch {file mkdir {$(WORKSPACE_TEMP_DIR)}}")
FACTORY_DEF * TeeFactory    FACTORY_NAME Duplicate_Tbl_File_Skipped_DirCreatorCleanerUpper    INPUT FEATURE_TYPE __nukeme__
# Send raster, point cloud and vector features down different paths to prepare
# them for viewing
FACTORY_DEF * TestFactory    FACTORY_NAME Duplicate_Tbl_File_Skipped_FeatureDirector    INPUT  FEATURE_TYPE Matcher_MATCHED    INPUT  FEATURE_TYPE StringSearcher_2_NOT_MATCHED    TEST &fme_type == "fme_raster"    OUTPUT FAILED FEATURE_TYPE Duplicate_Tbl_File_Skipped___NotRasterFeatures___    OUTPUT PASSED FEATURE_TYPE Duplicate_Tbl_File_Skipped___RasterFeatures___
FACTORY_DEF * TestFactory    FACTORY_NAME Duplicate_Tbl_File_Skipped___FeatureDirector1    INPUT FEATURE_TYPE Duplicate_Tbl_File_Skipped___NotRasterFeatures___    TEST &fme_type == "fme_point_cloud"    OUTPUT FAILED FEATURE_TYPE Duplicate_Tbl_File_Skipped___VectorFeatures___    OUTPUT PASSED FEATURE_TYPE Duplicate_Tbl_File_Skipped___PointCloudFeatures___
# Vector features simply may get their colors overridden
FACTORY_DEF * TeeFactory    FACTORY_NAME Duplicate_Tbl_File_Skipped_VectorSetterUpper    INPUT FEATURE_TYPE Duplicate_Tbl_File_Skipped___VectorFeatures___    OUTPUT FEATURE_TYPE __viewme__
# Point Cloud Features Might Need to be thinned
# Note that we don't call the ThinPointCloud function directly, but rather
# do it through TCL. This should allow this transformer to be used with a
# Desktop license, even though ThinPointCloud requires Professional.
Tcl2 proc Duplicate_Tbl_File_Skipped_08ab15f6_7329_43a8_b54b_b657a269a8bd0_thinPointCloud {} {    if {[string equal {NO_THINNING} {KEEPNPOINT}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {MAXNUMPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {FIRSTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }    elseif {[string equal {NO_THINNING} {LASTNPOINTS}]}    {       FME_Execute ThinPointCloud NO_THINNING "\"<Unused>\"";    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Duplicate_Tbl_File_Skipped___PointCloudThinner    INPUT FEATURE_TYPE Duplicate_Tbl_File_Skipped___PointCloudFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Duplicate_Tbl_File_Skipped_08ab15f6_7329_43a8_b54b_b657a269a8bd0_thinPointCloud")
Tcl2 proc Duplicate_Tbl_File_Skipped_08ab15f6_7329_43a8_b54b_b657a269a8bd0_prepareRaster {subsetStartRow subsetNumRows subsetStartCol subsetNumCols} {    set useDI [string equal -nocase {$(FME_VIEWER_APP)} {fmedatainspector}];    if {!$useDI} {       FME_Execute ApplyRasterRotation BILINEAR;    };    set doResample [string equal {NoReduction} {Resample}];    set doSubset [string equal {NoReduction} {Subset}];    set doBounds [string equal {NoReduction} {BoundingBoxOnly}];    if {$doBounds}  {       FME_Execute GeometryType fme_polygon;    }    elseif {$doResample || $doSubset} {       set comment {          First, we need to prefix all the attributes. This is done because          we are going to call @RasterProperties, and we want to make sure          it doesn't overwrite any existing attributes.       };       set kAttrPrefix ".";       set allNames [FME_AttributeNames];       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $newName $oldName;       };       FME_Execute RasterProperties RASTER;       if {$doResample} {          set oldNumCols [FME_GetAttribute _num_columns];          set oldNumRows [FME_GetAttribute _num_rows];          set oldSpacingX [FME_GetAttribute _spacing_x];          set oldSpacingY [FME_GetAttribute _spacing_y];          set kMinNumCells 32;          set kMaxNumCells 512;          set comment {             We will only resample if both dimensions are greater than the             minimum num cells, and at least one is greater than the maximum.          };          if {$oldNumRows > $kMinNumCells && $oldNumCols > $kMinNumCells && ($oldNumRows > $kMaxNumCells || $oldNumCols > $kMaxNumCells)} {             set newSpacingX 1.0;             set newSpacingY 1.0;             if {$oldNumRows > $oldNumCols} {                set comment {                   If we have more rows than columns, we need to choose a spacing                   that reduces the number of rows to the maximum we've chosen.                };                set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMaxNumCells];                set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                set comment {                   Now we need to check if doing this will result in the columns                   going below the minimum. If so, choose the spacing such that                   we only go down to the minimum (and not past).                };                set newNumCols [expr $oldNumCols * $oldSpacingX / $newSpacingX];                if {$newNumCols < $kMinNumCells}                {                   set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMinNumCells];                   set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                };             }             else {                set comment {                   This is identical to the above case, except the roles of                   rows and cols are reversed.                };                set newSpacingX [expr 1.0 * $oldNumCols * $oldSpacingX / $kMaxNumCells];                set newSpacingY [expr 1.0 * $newSpacingX / $oldSpacingX * $oldSpacingY];                set newNumRows [expr $oldNumRows * $oldSpacingY / $newSpacingY];                if {$newNumRows < $kMinNumCells}                {                   set newSpacingY [expr 1.0 * $oldNumRows * $oldSpacingY / $kMinNumCells];                   set newSpacingX [expr 1.0 * $newSpacingY / $oldSpacingY * $oldSpacingX];                };             };             FME_Execute ResampleRaster CELL_SIZE $newSpacingX $newSpacingY NearestNeighbor;          };       }       elseif {$doSubset} {          set comment {             Get the value of some strings that may be attributes or constants.             Note that we pass in the attribute prefix we're using, because if             one does turn out to be an attribute, it won't actually be the exact             name in the string (since we renamed all our attributes above).          };          set rasterNumRows [FME_GetAttribute _num_rows];          set rasterNumCols [FME_GetAttribute _num_columns];          set comment {             Only do subsetting if the specified start position is actually             within the raster.          };          if {$subsetStartRow < $rasterNumRows && $subsetStartCol < $rasterNumCols}          {             set comment {                Now bound the subset to the size of the raster, so that                we don't create padding.             };             if {[expr $subsetStartRow + $subsetNumRows] > $rasterNumRows}             {                set subsetNumRows [expr $rasterNumRows - $subsetStartRow];             };             if {[expr $subsetStartCol + $subsetNumCols] > $rasterNumCols}             {                set subsetNumCols [expr $rasterNumCols - $subsetStartCol];             };             FME_Execute SubsetRaster $subsetStartRow $subsetNumRows $subsetStartCol $subsetNumCols;          };       };       set comment {          Remove all the attributes added by @RasterProperties and remove the          prefix from the real attributes. We assume they all start with an          underscore.       };       FME_Execute RemoveAttributes fme_regexp_match {^_};       foreach oldName $allNames {          set newName $kAttrPrefix;          append newName $oldName;          FME_RenameAttribute $oldName $newName;       };    }; }
FACTORY_DEF * TeeFactory    FACTORY_NAME Duplicate_Tbl_File_Skipped_RasterSetterUpper    INPUT FEATURE_TYPE Duplicate_Tbl_File_Skipped___RasterFeatures___    OUTPUT FEATURE_TYPE __viewme__       @Tcl2("Duplicate_Tbl_File_Skipped_08ab15f6_7329_43a8_b54b_b657a269a8bd0_prepareRaster {<Unused>} {<Unused>} {<Unused>} {<Unused>}")
# Now route all the features into the recorder, changing their
# feature type to the transformer name so that they view nicely
# Duplicate_Tbl_File_Skipped_08ab15f6_7329_43a8_b54b_b657a269a8bd0_VIS_FEAT_TYPE changes the feature types
# of the features being visualized.
DEFAULT_MACRO Duplicate_Tbl_File_Skipped_08ab15f6_7329_43a8_b54b_b657a269a8bd0_VIS_FEAT_TYPE Duplicate_Tbl_File_Skipped$(CATMAC)
DEFAULT_MACRO VISUALIZER_FEATURE_FILE $(WORKSPACE_TEMP_DIR)/$(SAFE_FFS_NAME).ffs
DEFAULT_MACRO VISUALIZER_CREATE_SPATIAL_INDEX NO
# [PR#45549] The Data Inspector will limit the maximum number of features
# it reads on WIN32, so we will correspondingly limit the number of
# features we record here using the MAX_FEATURES_TO_RECORD directive.
FACTORY_DEF * RecorderFactory    FACTORY_NAME Duplicate_Tbl_File_Skipped_Recorder    INPUT FEATURE_TYPE __viewme__  _wb_termination_feature Yes @FeatureType(TERMINATOR_@Value(_wb_termination_xformer))    INPUT FEATURE_TYPE __viewme__  @FeatureType($(Duplicate_Tbl_File_Skipped_08ab15f6_7329_43a8_b54b_b657a269a8bd0_VIS_FEAT_TYPE))    FEATURE_FILE "$(VISUALIZER_FEATURE_FILE)"    CREATE_SPATIAL_INDEX "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    INSPECTOR "$(VISUALIZER_CREATE_SPATIAL_INDEX)"    FSC_SCHEMA path_unix,varchar<openparen>255<closeparen>,path_windows,varchar<openparen>255<closeparen>,path_rootname,varchar<openparen>255<closeparen>,path_filename,varchar<openparen>255<closeparen>,path_extension,varchar<openparen>255<closeparen>,path_filesize,varchar<openparen>255<closeparen>,path_ownername,varchar<openparen>255<closeparen>,path_readonly,varchar<openparen>255<closeparen>,path_modified_date,varchar<openparen>255<closeparen>,path_created_date,varchar<openparen>255<closeparen>,path_accessed_date,varchar<openparen>255<closeparen>,path_directory_unix,varchar<openparen>255<closeparen>,path_directory_windows,varchar<openparen>255<closeparen>,path_type,varchar<openparen>255<closeparen>,SurveyID_File,varchar<openparen>255<closeparen>,RecordName_File,varchar<openparen>255<closeparen>,_match_id,varchar<openparen>255<closeparen>    MODE RECORD    STORE_SCANNED_METADATA    RECORD_DIRECTLY_TO_DISK YES    MAX_FEATURES_TO_RECORD WIN32 2000000
# -------------------------------------------------------------------------

FACTORY_DEF * RoutingFactory FACTORY_NAME "Destination Feature Type Routing Correlator"   COMMAND_PARM_EVALUATION SINGLE_PASS   INPUT FEATURE_TYPE *    ROUTE FME_GENERIC Tester_5_FAILED_2_sBlGIaQhiac= TO CSV __GO_TO_FINAL_OUTPUT_ROUTER__ multi_writer_id,1,__wb_out_feat_type__,__nuke_me__ GEOMETRY    ROUTE FME_GENERIC BulkAttributeRenamer_2_OUTPUT TO POSTGRES __GO_TO_FINAL_OUTPUT_ROUTER__ multi_writer_id,0,<at>SupplyAttributes<openparen>ENCODED<comma>fme_template_feature_type<comma>Table1<closeparen>,<at>SupplyAttributes<openparen>ENCODED<comma>__wb_out_feat_type__<comma>Table1<closeparen>,<at>EvaluateExpression<openparen>ATTR_CREATE_EXPR<comma>__wb_out_feat_type__<comma><lt>at<gt>Value<lt>openparen<gt>_qual_tbl_name<lt>closeparen<gt><comma>Table1<closeparen> GEOMETRY    ROUTE FME_GENERIC AttributeExposer_OUTPUT TO POSTGRES __GO_TO_FINAL_OUTPUT_ROUTER__ multi_writer_id,2,<at>SupplyAttributes<openparen>ENCODED<comma>fme_template_feature_type<comma>REC91<closeparen>,<at>EvaluateExpression<openparen>ATTR_CREATE_EXPR<comma>__wb_out_feat_type__<comma><lt>at<gt>Value<lt>openparen<gt>_qual_tbl_name<lt>closeparen<gt><comma>REC91<closeparen> GEOMETRY    ROUTE FME_GENERIC __WB_BYPASS_TERMINATOR__ <at>Tcl2<openparen>FME_StatMessage<space>818062<space><opencurly><at>Value<openparen>_wb_termination_message<closeparen><space><openparen><at>Value<openparen>_wb_termination_xformer<closeparen><closeparen><closecurly><space>818063<closeparen> TO FME_GENERIC __WB_BYPASS_TERMINATOR__ __wb_out_feat_type__,__WB_BYPASS_TERMINATOR__ GEOMETRY   FEATURE_TYPE_ATTRIBUTE __wb_out_feat_type__   OUTPUT ROUTED FEATURE_TYPE *    OUTPUT NOT_ROUTED FEATURE_TYPE __nuke_me__ @Tcl2("FME_StatMessage 818059 [FME_GetAttribute fme_template_feature_type] 818060 818061 fme_warn")
# -------------------------------------------------------------------------

FACTORY_DEF * TeeFactory   FACTORY_NAME "Final Output Nuker"   INPUT FEATURE_TYPE __nuke_me__

# -------------------------------------------------------------------------

FACTORY_DEF * CreationFactory    FACTORY_NAME VisualizerProcessor   CREATE_AT_END   OUTPUT FEATURE_TYPE __NUKEME__   @TCL("if [file exists {$(WORKSPACE_TEMP_DIR)}] {set files [glob -nocomplain -directory  {$(WORKSPACE_TEMP_DIR)} -tails *.ffs];   if {[llength $files] == 1} {    set theFile {$(WORKSPACE_TEMP_DIR)/};   append theFile [lindex $files 0];   eval FME_Execute System \173\042$(FME_HOME_UNIX)/fmedatainspector\042 --visualizer --single-application --delete-on-close --no-source-prompt -f FFS \042$theFile\042 & \175;  } elseif { [llength $files] == 0 } {  catch { file delete -force {$(WORKSPACE_TEMP_DIR)} };  } else {  set filesNoExt {}; set lastfile {}; foreach {fileName} [lsort $files] { set fileNoExt [string trimright $fileName {.ffs}]; if [regexp {(.*)_[0-9]*$} $fileNoExt wholething fileNoExtBase] {  if { $fileNoExtBase == $lastfile } { continue } }; set lastfile $fileNoExt; lappend filesNoExt $fileNoExt };  eval FME_Execute System \173\042$(FME_HOME_UNIX)/fmedatainspector\042 --visualizer --single-application --delete-on-close --no-source-prompt -d {$(WORKSPACE_TEMP_DIR)} -a ffs -f FFS $filesNoExt & \175; }; }; ")
FACTORY_DEF * TeeFactory    FACTORY_NAME VisualizerCleaner   INPUT FEATURE_TYPE __NUKEME__
# -------------------------------------------------------------------------
POSTGRES_1_DEF_TEMPLATE Table1   postgres_type                <All>   postgres_mode                INHERIT_FROM_WRITER   postgres_sql_key_columns     ""   postgres_drop_table          NO   postgres_truncate_table      NO   postgres_create_with_oids    YES   postgres_vacuum_analyze      YES   postgres_allow_serial_writing NO   fme_schema_readers           ""   fme_schema_feature_first     Yes   fme_schema_name_expression   @EvaluateExpression(FDIV,STRING,<at>Value<openparen>RecordName<closeparen>,<at>Value<openparen>_qual_tbl_name<closeparen>)
# -------------------------------------------------------------------------
POSTGRES_2_DEF REC91   postgres_type                All   postgres_sql_key_columns     ""   postgres_drop_table          ""   postgres_truncate_table      ""   postgres_mode                ""   fme_feature_operation        INSERT   fme_table_handling           USE_EXISTING   postgres_create_with_oids    NO   postgres_vacuum_analyze      NO   postgres_allow_serial_writing NO   surveyid                     varchar(3)   data                         text
